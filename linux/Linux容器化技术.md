# Linux 容器化技术

> 📖 参考书籍：《深入理解 Linux 进程与内存》
>
> 🤖 笔记方式：阅读书籍 + AI 辅助答疑整理
>
> 本文探讨 Linux 容器化技术的原理，从虚拟机到容器的演进，以及 Namespace 和 Cgroup 两大核心机制。

## 目录

1. [容器化的发展](#1-容器化的发展)
2. [Namespace（命名空间）](#2-namespace命名空间)
3. [Cgroup（控制组）](#3-cgroup控制组)
4. [PID Namespace 详解](#4-pid-namespace-详解)

---

## 1. 容器化的发展

### 1.1 为什么需要隔离？

在服务器上运行多个应用时，我们希望：

```
┌─────────────────────────────────────────────────────────────────┐
│                      隔离的需求                                  │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│   1. 资源隔离                                                   │
│      └── 应用 A 不能占用应用 B 的 CPU、内存                     │
│                                                                 │
│   2. 环境隔离                                                   │
│      └── 应用 A 用 Python 2，应用 B 用 Python 3，互不干扰       │
│                                                                 │
│   3. 安全隔离                                                   │
│      └── 应用 A 不能访问应用 B 的文件、网络                     │
│                                                                 │
│   4. 故障隔离                                                   │
│      └── 应用 A 崩溃不影响应用 B                                │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

### 1.2 虚拟机时代

虚拟机（Virtual Machine）是最早的隔离方案：

```
┌─────────────────────────────────────────────────────────────────┐
│                      虚拟机架构                                  │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│   ┌─────────────┐  ┌─────────────┐  ┌─────────────┐            │
│   │    App A    │  │    App B    │  │    App C    │            │
│   ├─────────────┤  ├─────────────┤  ├─────────────┤            │
│   │   Bins/Libs │  │   Bins/Libs │  │   Bins/Libs │            │
│   ├─────────────┤  ├─────────────┤  ├─────────────┤            │
│   │  Guest OS   │  │  Guest OS   │  │  Guest OS   │            │
│   │  (完整内核) │  │  (完整内核) │  │  (完整内核) │            │
│   └─────────────┘  └─────────────┘  └─────────────┘            │
│   ─────────────────────────────────────────────────            │
│                     Hypervisor（虚拟机管理器）                   │
│                     VMware / KVM / Xen                          │
│   ─────────────────────────────────────────────────            │
│                        Host OS（宿主机）                         │
│   ─────────────────────────────────────────────────            │
│                        Hardware（硬件）                          │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

**虚拟机的特点**：

| 优点 | 缺点 |
|------|------|
| 完全隔离（独立内核） | 资源开销大（每个 VM 一个完整 OS） |
| 安全性高 | 启动慢（分钟级） |
| 可以运行不同 OS | 镜像体积大（GB 级） |
| 成熟稳定 | 性能损耗（虚拟化开销） |

### 1.3 容器时代

容器（Container）是更轻量的隔离方案：

```
┌─────────────────────────────────────────────────────────────────┐
│                      容器架构                                    │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│   ┌─────────────┐  ┌─────────────┐  ┌─────────────┐            │
│   │    App A    │  │    App B    │  │    App C    │            │
│   ├─────────────┤  ├─────────────┤  ├─────────────┤            │
│   │   Bins/Libs │  │   Bins/Libs │  │   Bins/Libs │            │
│   └─────────────┘  └─────────────┘  └─────────────┘            │
│   ─────────────────────────────────────────────────            │
│                     Container Runtime                           │
│                     Docker / containerd / runc                  │
│   ─────────────────────────────────────────────────            │
│                        Host OS（共享内核）                       │
│   ─────────────────────────────────────────────────            │
│                        Hardware（硬件）                          │
│                                                                 │
│   关键区别：容器共享宿主机内核，没有 Guest OS！                 │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

**容器的特点**：

| 优点 | 缺点 |
|------|------|
| 轻量（共享内核） | 隔离性不如 VM（共享内核） |
| 启动快（秒级） | 只能运行与宿主机相同的 OS |
| 镜像小（MB 级） | 安全性相对较低 |
| 性能接近原生 | 内核漏洞影响所有容器 |

### 1.4 虚拟机 vs 容器

```
┌─────────────────────────────────────────────────────────────────┐
│                  虚拟机 vs 容器 对比                             │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│              虚拟机                        容器                 │
│   ┌───────────────────────┐    ┌───────────────────────┐       │
│   │        App            │    │        App            │       │
│   ├───────────────────────┤    ├───────────────────────┤       │
│   │      Bins/Libs        │    │      Bins/Libs        │       │
│   ├───────────────────────┤    └───────────────────────┘       │
│   │      Guest OS         │              ↓                     │
│   │    （完整内核）       │         共享宿主机内核             │
│   └───────────────────────┘                                    │
│              ↓                                                  │
│         Hypervisor                  Container Runtime          │
│              ↓                              ↓                   │
│          Host OS                        Host OS                │
│              ↓                              ↓                   │
│          Hardware                       Hardware               │
│                                                                 │
│   ┌─────────────────────────────────────────────────────────┐  │
│   │ 指标         │ 虚拟机          │ 容器                   │  │
│   ├─────────────────────────────────────────────────────────┤  │
│   │ 启动时间     │ 分钟级          │ 秒级                   │  │
│   │ 镜像大小     │ GB 级           │ MB 级                  │  │
│   │ 性能         │ 有损耗          │ 接近原生               │  │
│   │ 隔离级别     │ 硬件级          │ 进程级                 │  │
│   │ 内核         │ 独立内核        │ 共享内核               │  │
│   │ 密度         │ 单机几十个      │ 单机几百上千个         │  │
│   └─────────────────────────────────────────────────────────┘  │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

### 1.5 容器的本质

**容器不是虚拟机，容器就是一个特殊的进程！**

```
┌─────────────────────────────────────────────────────────────────┐
│                      容器的本质                                  │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│   容器 = 受限制的进程                                           │
│                                                                 │
│   Linux 内核提供两个机制：                                      │
│                                                                 │
│   1. Namespace（命名空间）                                      │
│      └── 隔离：让进程看到独立的系统视图                         │
│          （独立的 PID、网络、文件系统...）                      │
│                                                                 │
│   2. Cgroup（控制组）                                           │
│      └── 限制：限制进程能使用的资源                             │
│          （CPU、内存、IO...）                                   │
│                                                                 │
│   容器 = Namespace（隔离） + Cgroup（限制） + rootfs（文件系统）│
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

---

## 2. Namespace（命名空间）

### 2.1 什么是 Namespace？

Namespace 是 Linux 内核提供的**资源隔离机制**，让进程拥有独立的系统视图。

```
┌─────────────────────────────────────────────────────────────────┐
│                    Namespace 的作用                              │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│   没有 Namespace：                                              │
│   ┌─────────────────────────────────────────────────────────┐  │
│   │  进程 A 和 进程 B 看到相同的系统视图                     │  │
│   │  ├── 相同的 PID 空间（能看到对方）                       │  │
│   │  ├── 相同的网络（共享 IP、端口）                         │  │
│   │  ├── 相同的文件系统                                      │  │
│   │  └── 相同的用户                                          │  │
│   └─────────────────────────────────────────────────────────┘  │
│                                                                 │
│   有 Namespace：                                                │
│   ┌──────────────────────┐  ┌──────────────────────┐           │
│   │  进程 A 的视图       │  │  进程 B 的视图       │           │
│   │  ├── 自己是 PID 1    │  │  ├── 自己是 PID 1    │           │
│   │  ├── 独立的网络栈    │  │  ├── 独立的网络栈    │           │
│   │  ├── 独立的文件系统  │  │  ├── 独立的文件系统  │           │
│   │  └── 独立的用户      │  │  └── 独立的用户      │           │
│   └──────────────────────┘  └──────────────────────┘           │
│                                                                 │
│   进程 A 和 B 互相看不到对方，以为自己独占整个系统              │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

### 2.2 Namespace 的类型

Linux 提供了 8 种 Namespace：

```
┌─────────────────────────────────────────────────────────────────┐
│                    Namespace 类型                                │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│   类型          │ 隔离内容                    │ 内核版本        │
│   ─────────────────────────────────────────────────────────────│
│   Mount (mnt)   │ 文件系统挂载点              │ 2.4.19          │
│   UTS           │ 主机名和域名                │ 2.6.19          │
│   IPC           │ 进程间通信（信号量、消息队列）│ 2.6.19          │
│   PID           │ 进程 ID                     │ 2.6.24          │
│   Network (net) │ 网络栈（IP、端口、路由）    │ 2.6.29          │
│   User          │ 用户和组 ID                 │ 3.8             │
│   Cgroup        │ Cgroup 根目录               │ 4.6             │
│   Time          │ 系统时间                    │ 5.6             │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

### 2.3 各 Namespace 详解

#### PID Namespace

```
┌─────────────────────────────────────────────────────────────────┐
│                    PID Namespace                                 │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│   作用：隔离进程 ID 空间                                        │
│                                                                 │
│   宿主机视角：                    容器内视角：                  │
│   ┌──────────────────┐           ┌──────────────────┐          │
│   │ PID 1: systemd   │           │ PID 1: nginx     │ ← 容器   │
│   │ PID 2: ...       │           │ PID 2: worker    │   内以为 │
│   │ ...              │           │ ...              │   自己是 │
│   │ PID 1000: nginx  │ ────────→ │                  │   PID 1  │
│   │ PID 1001: worker │           │                  │          │
│   └──────────────────┘           └──────────────────┘          │
│                                                                 │
│   容器内的进程以为自己是 PID 1（init 进程）                     │
│   实际上在宿主机是普通进程（如 PID 1000）                       │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

#### Network Namespace

```
┌─────────────────────────────────────────────────────────────────┐
│                    Network Namespace                             │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│   作用：隔离网络栈（网卡、IP、端口、路由表、iptables）          │
│                                                                 │
│   ┌─────────────────────────────────────────────────────────┐  │
│   │                      宿主机                              │  │
│   │  ┌─────────────┐              ┌─────────────┐           │  │
│   │  │ 容器 A      │              │ 容器 B      │           │  │
│   │  │ eth0:       │              │ eth0:       │           │  │
│   │  │ 172.17.0.2  │              │ 172.17.0.3  │           │  │
│   │  │ :80 nginx   │              │ :80 nginx   │ ← 都用80  │  │
│   │  └──────┬──────┘              └──────┬──────┘   不冲突  │  │
│   │         │ veth                       │ veth             │  │
│   │         └───────────┬────────────────┘                  │  │
│   │                     │                                   │  │
│   │              ┌──────┴──────┐                            │  │
│   │              │  docker0    │  虚拟网桥                  │  │
│   │              │ 172.17.0.1  │                            │  │
│   │              └──────┬──────┘                            │  │
│   │                     │                                   │  │
│   │              ┌──────┴──────┐                            │  │
│   │              │    eth0     │  物理网卡                  │  │
│   │              │ 192.168.1.x │                            │  │
│   │              └─────────────┘                            │  │
│   └─────────────────────────────────────────────────────────┘  │
│                                                                 │
│   每个容器有独立的网络栈，可以绑定相同端口                      │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

#### Mount Namespace

```
┌─────────────────────────────────────────────────────────────────┐
│                    Mount Namespace                               │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│   作用：隔离文件系统挂载点                                      │
│                                                                 │
│   宿主机：                        容器：                        │
│   /                               /  ← 容器的根目录             │
│   ├── bin/                        ├── bin/   (容器自己的)       │
│   ├── etc/                        ├── etc/   (容器自己的)       │
│   ├── home/                       ├── home/                     │
│   ├── var/                        ├── var/                      │
│   │   └── lib/                    └── ...                       │
│   │       └── docker/                                           │
│   │           └── overlay2/                                     │
│   │               └── xxx/merged/ ──→ 这就是容器看到的 /        │
│   └── ...                                                       │
│                                                                 │
│   容器看到的是独立的文件系统（通常是镜像 + 可写层）             │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

#### UTS Namespace

```
┌─────────────────────────────────────────────────────────────────┐
│                    UTS Namespace                                 │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│   作用：隔离主机名和域名                                        │
│                                                                 │
│   宿主机：                        容器：                        │
│   $ hostname                      $ hostname                    │
│   my-server                       my-container                  │
│                                                                 │
│   容器可以有自己的主机名，不影响宿主机                          │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

#### User Namespace

```
┌─────────────────────────────────────────────────────────────────┐
│                    User Namespace                                │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│   作用：隔离用户和组 ID                                         │
│                                                                 │
│   宿主机：                        容器内：                      │
│   UID 1000 (普通用户)      ──→    UID 0 (root)                  │
│                                                                 │
│   容器内的 root 实际上是宿主机的普通用户                        │
│   提高安全性：即使容器被攻破，也只是普通用户权限                │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

### 2.4 Namespace 的操作

```
┌─────────────────────────────────────────────────────────────────┐
│                    Namespace 相关系统调用                        │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│   1. clone() - 创建新进程时指定 Namespace                       │
│      clone(CLONE_NEWPID | CLONE_NEWNET | ...)                   │
│                                                                 │
│   2. unshare() - 当前进程脱离某个 Namespace                     │
│      unshare(CLONE_NEWNET)  // 创建新的网络命名空间             │
│                                                                 │
│   3. setns() - 加入已存在的 Namespace                           │
│      setns(fd, CLONE_NEWNET)  // 加入某个网络命名空间           │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

```bash
# 查看进程的 Namespace
ls -la /proc/<pid>/ns/

# 示例输出
lrwxrwxrwx 1 root root 0 Dec 26 10:00 cgroup -> 'cgroup:[4026531835]'
lrwxrwxrwx 1 root root 0 Dec 26 10:00 ipc -> 'ipc:[4026531839]'
lrwxrwxrwx 1 root root 0 Dec 26 10:00 mnt -> 'mnt:[4026531840]'
lrwxrwxrwx 1 root root 0 Dec 26 10:00 net -> 'net:[4026531992]'
lrwxrwxrwx 1 root root 0 Dec 26 10:00 pid -> 'pid:[4026531836]'
lrwxrwxrwx 1 root root 0 Dec 26 10:00 user -> 'user:[4026531837]'
lrwxrwxrwx 1 root root 0 Dec 26 10:00 uts -> 'uts:[4026531838]'

# 方括号里的数字是 Namespace 的 inode 号
# 相同的数字表示在同一个 Namespace
```

---

## 3. Cgroup（控制组）

### 3.1 什么是 Cgroup？

Cgroup（Control Group）是 Linux 内核提供的**资源限制机制**。

```
┌─────────────────────────────────────────────────────────────────┐
│                    Cgroup 的作用                                 │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│   Namespace 解决了"看到什么"的问题（隔离）                      │
│   Cgroup 解决了"能用多少"的问题（限制）                         │
│                                                                 │
│   没有 Cgroup：                                                 │
│   └── 容器可以无限制使用 CPU、内存，影响其他容器和宿主机        │
│                                                                 │
│   有 Cgroup：                                                   │
│   └── 可以限制容器最多用 2 核 CPU、4GB 内存                     │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

### 3.2 Cgroup 能限制什么？

```
┌─────────────────────────────────────────────────────────────────┐
│                    Cgroup 子系统（控制器）                       │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│   子系统        │ 限制内容                                      │
│   ─────────────────────────────────────────────────────────────│
│   cpu           │ CPU 使用时间配额                              │
│   cpuset        │ 绑定到特定 CPU 核心                           │
│   cpuacct       │ CPU 使用统计                                  │
│   memory        │ 内存使用限制                                  │
│   blkio         │ 块设备 I/O 限制                               │
│   devices       │ 设备访问控制                                  │
│   net_cls       │ 网络数据包分类                                │
│   net_prio      │ 网络优先级                                    │
│   freezer       │ 暂停/恢复进程                                 │
│   pids          │ 进程数量限制                                  │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

### 3.3 Cgroup 的层级结构

```
┌─────────────────────────────────────────────────────────────────┐
│                    Cgroup 层级结构                               │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│   Cgroup 是树形结构，子节点继承父节点的限制：                   │
│                                                                 │
│   /sys/fs/cgroup/                                               │
│   ├── cpu/                        # CPU 子系统                  │
│   │   ├── docker/                 # Docker 的 cgroup            │
│   │   │   ├── container_a/        # 容器 A                      │
│   │   │   │   ├── cpu.cfs_quota_us    # CPU 配额               │
│   │   │   │   ├── cpu.cfs_period_us   # CPU 周期               │
│   │   │   │   └── tasks               # 属于这个组的进程        │
│   │   │   └── container_b/        # 容器 B                      │
│   │   └── ...                                                   │
│   ├── memory/                     # 内存子系统                  │
│   │   ├── docker/                                               │
│   │   │   ├── container_a/                                      │
│   │   │   │   ├── memory.limit_in_bytes  # 内存限制            │
│   │   │   │   ├── memory.usage_in_bytes  # 当前使用量          │
│   │   │   │   └── tasks                                         │
│   │   │   └── container_b/                                      │
│   │   └── ...                                                   │
│   └── ...                                                       │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

### 3.4 常用 Cgroup 限制示例

#### CPU 限制

```
┌─────────────────────────────────────────────────────────────────┐
│                    CPU 限制                                      │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│   方式 1：CPU 配额（cpu.cfs_quota_us / cpu.cfs_period_us）      │
│                                                                 │
│   cpu.cfs_period_us = 100000  (100ms)                           │
│   cpu.cfs_quota_us  = 50000   (50ms)                            │
│   → 每 100ms 最多使用 50ms CPU = 0.5 核                         │
│                                                                 │
│   cpu.cfs_quota_us  = 200000  (200ms)                           │
│   → 每 100ms 最多使用 200ms CPU = 2 核                          │
│                                                                 │
│   方式 2：绑定 CPU 核心（cpuset.cpus）                          │
│                                                                 │
│   cpuset.cpus = 0,1    # 只能使用 CPU 0 和 1                    │
│   cpuset.cpus = 0-3    # 只能使用 CPU 0,1,2,3                   │
│                                                                 │
│   Docker 命令：                                                 │
│   docker run --cpus=0.5 ...        # 限制 0.5 核                │
│   docker run --cpuset-cpus=0,1 ... # 绑定到 CPU 0,1             │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

#### 内存限制

```
┌─────────────────────────────────────────────────────────────────┐
│                    内存限制                                      │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│   memory.limit_in_bytes = 1073741824  (1GB)                     │
│   → 最多使用 1GB 内存                                           │
│                                                                 │
│   memory.soft_limit_in_bytes = 536870912  (512MB)               │
│   → 软限制，内存紧张时优先回收                                  │
│                                                                 │
│   memory.oom_control                                            │
│   → 是否启用 OOM Killer                                         │
│                                                                 │
│   超过限制会怎样？                                              │
│   ├── 触发 OOM Killer，杀死容器内进程                           │
│   └── 或者触发内存回收（swap）                                  │
│                                                                 │
│   Docker 命令：                                                 │
│   docker run --memory=1g ...       # 限制 1GB 内存              │
│   docker run --memory-swap=2g ...  # 内存+swap 共 2GB           │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

### 3.5 Cgroup v1 vs v2

Cgroup 有两个版本，v2 是对 v1 的重新设计。

#### Cgroup v1 的结构

```
┌─────────────────────────────────────────────────────────────────┐
│                    Cgroup v1 结构                                │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│   每个子系统有独立的层级树：                                    │
│                                                                 │
│   /sys/fs/cgroup/                                               │
│   ├── cpu/                    # CPU 子系统的层级树              │
│   │   ├── docker/                                               │
│   │   │   ├── container_a/                                      │
│   │   │   └── container_b/                                      │
│   │   └── user/                                                 │
│   │                                                             │
│   ├── memory/                 # 内存子系统的层级树（独立！）    │
│   │   ├── docker/                                               │
│   │   │   ├── container_a/                                      │
│   │   │   └── container_b/                                      │
│   │   └── user/                                                 │
│   │                                                             │
│   ├── blkio/                  # IO 子系统的层级树（又独立！）   │
│   │   └── ...                                                   │
│   └── ...                                                       │
│                                                                 │
│   问题：                                                        │
│   ├── 一个进程可能在不同子系统的不同位置                        │
│   ├── 管理复杂，容易出错                                        │
│   └── 某些资源限制难以协调（如 CPU 和内存的联合限制）           │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

#### Cgroup v2 的结构

```
┌─────────────────────────────────────────────────────────────────┐
│                    Cgroup v2 结构                                │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│   所有子系统统一的层级树：                                      │
│                                                                 │
│   /sys/fs/cgroup/                                               │
│   ├── cgroup.controllers      # 可用的控制器列表                │
│   ├── cgroup.subtree_control  # 子树启用的控制器                │
│   │                                                             │
│   ├── docker/                                                   │
│   │   ├── container_a/                                          │
│   │   │   ├── cgroup.controllers                                │
│   │   │   ├── cpu.max          # CPU 限制                       │
│   │   │   ├── memory.max       # 内存限制                       │
│   │   │   ├── io.max           # IO 限制                        │
│   │   │   └── cgroup.procs     # 进程列表                       │
│   │   │                                                         │
│   │   └── container_b/                                          │
│   │       └── ...                                               │
│   │                                                             │
│   └── user.slice/                                               │
│       └── ...                                                   │
│                                                                 │
│   优势：                                                        │
│   ├── 一个进程在一个位置，所有资源限制集中管理                  │
│   ├── 结构清晰，不会出现不一致                                  │
│   └── 更容易实现资源的联合限制                                  │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

#### 核心区别对比

```
┌─────────────────────────────────────────────────────────────────┐
│                    v1 vs v2 核心区别                             │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│   特性              │ Cgroup v1           │ Cgroup v2           │
│   ─────────────────────────────────────────────────────────────│
│   层级结构          │ 多棵树（每子系统一棵）│ 单棵统一树          │
│   进程归属          │ 可在不同子系统不同位置│ 只能在一个位置      │
│   控制器绑定        │ 一个层级绑定多个控制器│ 控制器按需启用      │
│   线程支持          │ 不支持               │ 支持线程级控制      │
│   压力监控（PSI）   │ 不支持               │ 支持                │
│   接口文件          │ 各子系统不同         │ 统一命名规范        │
│                                                                 │
│   接口文件命名对比：                                            │
│   ─────────────────────────────────────────────────────────────│
│   v1: cpu.cfs_quota_us        v2: cpu.max                       │
│   v1: memory.limit_in_bytes   v2: memory.max                    │
│   v1: blkio.throttle.*        v2: io.max                        │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

#### v2 的新特性

```
┌─────────────────────────────────────────────────────────────────┐
│                    Cgroup v2 新特性                              │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│   1. 压力阻塞信息（PSI - Pressure Stall Information）           │
│      ├── cpu.pressure：CPU 压力                                 │
│      ├── memory.pressure：内存压力                              │
│      └── io.pressure：IO 压力                                   │
│                                                                 │
│      $ cat /sys/fs/cgroup/docker/container_a/cpu.pressure       │
│      some avg10=0.00 avg60=0.00 avg300=0.00 total=0             │
│      full avg10=0.00 avg60=0.00 avg300=0.00 total=0             │
│                                                                 │
│   2. 线程模式（threaded）                                       │
│      └── 可以对线程级别进行资源控制                             │
│                                                                 │
│   3. 更好的内存控制                                             │
│      ├── memory.high：软限制，超过会被限流                      │
│      ├── memory.max：硬限制，超过触发 OOM                       │
│      └── memory.low：保护，低于此值不会被回收                   │
│                                                                 │
│   4. 统一的接口                                                 │
│      └── 所有控制器使用相同的命名规范                           │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

#### 如何查看系统使用的版本

```bash
# 查看挂载的 cgroup 文件系统
mount | grep cgroup

# v1 输出示例：
# cgroup on /sys/fs/cgroup/cpu type cgroup (rw,cpu)
# cgroup on /sys/fs/cgroup/memory type cgroup (rw,memory)

# v2 输出示例：
# cgroup2 on /sys/fs/cgroup type cgroup2 (rw,nosuid,nodev,noexec)

# 或者检查目录结构
ls /sys/fs/cgroup/
# v1: cpu/ memory/ blkio/ ...（多个目录）
# v2: cgroup.controllers cgroup.procs ...（统一目录）
```

#### 目前状态

```
┌─────────────────────────────────────────────────────────────────┐
│                    Cgroup 版本现状                               │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│   内核支持：                                                    │
│   ├── v1：Linux 2.6.24+（2008年）                               │
│   ├── v2：Linux 4.5+（2016年），5.x 后稳定                      │
│   └── 可以同时挂载 v1 和 v2（混合模式）                         │
│                                                                 │
│   容器运行时支持：                                              │
│   ├── Docker 20.10+：支持 v2                                    │
│   ├── containerd 1.4+：支持 v2                                  │
│   ├── Kubernetes 1.25+：默认使用 v2                             │
│   └── systemd 226+：支持 v2                                     │
│                                                                 │
│   发行版默认：                                                  │
│   ├── Ubuntu 21.10+：默认 v2                                    │
│   ├── Fedora 31+：默认 v2                                       │
│   ├── RHEL 9+：默认 v2                                          │
│   └── 旧系统：默认 v1                                           │
│                                                                 │
│   建议：新项目使用 v2，旧系统逐步迁移                           │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

---

## 4. PID Namespace 详解

PID Namespace 是容器隔离的核心之一，让我们深入了解它的实现原理。

### 4.1 两个核心概念：树形结构与层级（Level）

在深入 PID Namespace 之前，必须先理解两个核心概念：

```
┌─────────────────────────────────────────────────────────────────┐
│                    PID Namespace 的核心概念                      │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│   1. 树形结构（Tree Structure）                                 │
│      ├── PID Namespace 组织成一棵树                             │
│      ├── 每个 Namespace 有一个父 Namespace（除了根）            │
│      ├── 可以有多个子 Namespace                                 │
│      └── 父子关系决定了可见性                                   │
│                                                                 │
│   2. 层级（Level）                                              │
│      ├── 表示 Namespace 在树中的深度                            │
│      ├── 根 Namespace（init_pid_ns）的 level = 0                │
│      ├── 子 Namespace 的 level = 父 level + 1                   │
│      └── level 决定了进程需要多少个 PID                         │
│                                                                 │
│   ┌─────────────────────────────────────────────────────────┐  │
│   │                                                          │  │
│   │   level 0:        init_pid_ns (根)                       │  │
│   │                    /        \                            │  │
│   │   level 1:    ns_A            ns_B                       │  │
│   │               /                  \                       │  │
│   │   level 2:  ns_C                 ns_D                    │  │
│   │                                                          │  │
│   │   树形结构 + level 共同决定：                            │  │
│   │   ├── 谁能看到谁（父能看子，子看不到父）                 │  │
│   │   ├── 进程有几个 PID（level + 1 个）                     │  │
│   │   └── PID 如何分配（从子到父递归）                       │  │
│   │                                                          │  │
│   └─────────────────────────────────────────────────────────┘  │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

**为什么这两个概念重要？**

```
┌─────────────────────────────────────────────────────────────────┐
│                    Level 的作用                                  │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│   1. 决定 struct pid 的大小                                     │
│      └── pid->numbers[] 数组长度 = level + 1                    │
│          level 2 的进程需要存储 3 个 PID（level 0, 1, 2）       │
│                                                                 │
│   2. 决定 PID 分配的递归深度                                    │
│      └── 从当前 level 向上递归到 level 0                        │
│                                                                 │
│   3. 决定可见性判断                                             │
│      └── 只有 level <= 进程 level 的 Namespace 才能看到它       │
│                                                                 │
│   内核中的 level：                                              │
│   struct pid_namespace {                                        │
│       ...                                                       │
│       unsigned int level;  // 关键字段！                        │
│       struct pid_namespace *parent;  // 父 Namespace            │
│       ...                                                       │
│   };                                                            │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

### 4.3 默认命名空间 init_pid_ns

系统启动时，内核会创建一个**初始的 PID 命名空间**：`init_pid_ns`，它是整棵树的根节点。

```
┌─────────────────────────────────────────────────────────────────┐
│                    init_pid_ns（根命名空间）                     │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│   系统启动时：                                                  │
│   ├── 内核创建 init_pid_ns 作为根 PID 命名空间                  │
│   ├── PID 1 进程（init/systemd）运行在这个命名空间              │
│   └── 所有普通进程默认都在这个命名空间                          │
│                                                                 │
│   ┌─────────────────────────────────────────────────────────┐  │
│   │                   init_pid_ns                            │  │
│   │                                                          │  │
│   │   PID 1: systemd (init)                                  │  │
│   │   PID 2: kthreadd                                        │  │
│   │   ...                                                    │  │
│   │   PID 1000: sshd                                         │  │
│   │   PID 1001: bash                                         │  │
│   │   ...                                                    │  │
│   │                                                          │  │
│   │   所有进程都能互相看到                                   │  │
│   │                                                          │  │
│   └─────────────────────────────────────────────────────────┘  │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

```c
// kernel/pid_namespace.c
struct pid_namespace init_pid_ns = {
    .kref = KREF_INIT(2),
    .idr = IDR_INIT(init_pid_ns.idr),
    .pid_allocated = PIDNS_ADDING,
    .level = 0,                    // 层级 0，根命名空间
    .child_reaper = &init_task,    // PID 1 进程
    .user_ns = &init_user_ns,
    .ns.inum = PROC_PID_INIT_INO,
    .ns.ops = &pidns_operations,
};
```

### 4.4 PID Namespace 的层级结构

PID Namespace 是**树形层级结构**，可以嵌套。每创建一个子 Namespace，level 就加 1：

```
┌─────────────────────────────────────────────────────────────────┐
│                    PID Namespace 层级                            │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│   level 0:  init_pid_ns（根命名空间）                           │
│             ┌─────────────────────────────────────────────┐     │
│             │  PID 1: systemd                             │     │
│             │  PID 100: dockerd                           │     │
│             │  PID 200: container_A (在宿主机看是200)     │     │
│             │  PID 300: container_B (在宿主机看是300)     │     │
│             └─────────────────────────────────────────────┘     │
│                        │                    │                   │
│                        ↓                    ↓                   │
│   level 1:    ┌──────────────┐      ┌──────────────┐           │
│               │ 容器 A 的    │      │ 容器 B 的    │           │
│               │ pid_ns       │      │ pid_ns       │           │
│               │              │      │              │           │
│               │ PID 1: nginx │      │ PID 1: redis │           │
│               │ PID 2: worker│      │ PID 2: ...   │           │
│               └──────────────┘      └──────────────┘           │
│                        │                                        │
│                        ↓                                        │
│   level 2:    ┌──────────────┐                                 │
│               │ 嵌套容器的   │                                 │
│               │ pid_ns       │                                 │
│               │              │                                 │
│               │ PID 1: app   │                                 │
│               └──────────────┘                                 │
│                                                                 │
│   规则：                                                        │
│   ├── 父命名空间能看到子命名空间的进程                          │
│   ├── 子命名空间看不到父命名空间的进程                          │
│   └── 同级命名空间互相看不到                                    │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

### 4.5 进程的多个 PID

一个进程在不同层级的命名空间中有**不同的 PID**。进程的 PID 数量 = level + 1：

```
┌─────────────────────────────────────────────────────────────────┐
│                    一个进程，多个 PID                            │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│   容器内的 nginx 进程：                                         │
│                                                                 │
│   ┌─────────────────────────────────────────────────────────┐  │
│   │  在 init_pid_ns（宿主机）看：PID = 12345                 │  │
│   │  在容器的 pid_ns 看：        PID = 1                     │  │
│   └─────────────────────────────────────────────────────────┘  │
│                                                                 │
│   内核数据结构：                                                │
│                                                                 │
│   struct task_struct {                                          │
│       ...                                                       │
│       struct pid *thread_pid;  // 指向 pid 结构                 │
│       ...                                                       │
│   };                                                            │
│                                                                 │
│   struct pid {                                                  │
│       refcount_t count;                                         │
│       unsigned int level;       // 所在的最深层级               │
│       struct hlist_head tasks[PIDTYPE_MAX];                     │
│       struct upid numbers[1];   // 柔性数组，每层一个 upid      │
│   };                                                            │
│                                                                 │
│   struct upid {                                                 │
│       int nr;                   // 在该层级的 PID 号            │
│       struct pid_namespace *ns; // 所属的命名空间               │
│   };                                                            │
│                                                                 │
│   示例：                                                        │
│   pid->level = 1  (在 level 1 的命名空间创建)                   │
│   pid->numbers[0] = { nr: 12345, ns: init_pid_ns }  // 宿主机   │
│   pid->numbers[1] = { nr: 1,     ns: container_ns } // 容器内   │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

### 4.6 PID 分配的递归过程

当在子命名空间创建进程时，需要**从子到父递归分配 PID**，递归深度由 level 决定：

```
┌─────────────────────────────────────────────────────────────────┐
│                    PID 分配的递归过程                            │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│   场景：在 level 2 的命名空间中 fork() 创建新进程               │
│                                                                 │
│   level 0: init_pid_ns                                          │
│            ↑ 3. 分配 PID = 12345                                │
│            │                                                    │
│   level 1: container_ns                                         │
│            ↑ 2. 分配 PID = 50                                   │
│            │                                                    │
│   level 2: nested_ns                                            │
│            ↑ 1. 分配 PID = 1（从这里开始）                      │
│            │                                                    │
│         新进程                                                  │
│                                                                 │
│   分配顺序（从子到父）：                                        │
│   1. 先在当前命名空间（level 2）分配 PID = 1                    │
│   2. 然后在父命名空间（level 1）分配 PID = 50                   │
│   3. 最后在根命名空间（level 0）分配 PID = 12345                │
│                                                                 │
│   结果：新进程有 3 个 PID                                       │
│   pid->numbers[0] = { nr: 12345, ns: init_pid_ns }              │
│   pid->numbers[1] = { nr: 50,    ns: container_ns }             │
│   pid->numbers[2] = { nr: 1,     ns: nested_ns }                │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

#### 内核实现

```c
// kernel/pid.c
struct pid *alloc_pid(struct pid_namespace *ns, ...)
{
    struct pid *pid;
    int i;
    
    // 分配 pid 结构，大小取决于层级深度
    pid = kmem_cache_alloc(...);
    pid->level = ns->level;
    
    // 从当前命名空间向上递归，为每一层分配 PID
    for (i = ns->level; i >= 0; i--) {
        struct pid_namespace *tmp = ns;
        
        // 找到第 i 层的命名空间
        for (int j = ns->level; j > i; j--)
            tmp = tmp->parent;
        
        // 在该层分配一个 PID 号
        nr = idr_alloc(&tmp->idr, ...);  // 分配唯一的 PID 号
        
        // 记录到 pid->numbers 数组
        pid->numbers[i].nr = nr;
        pid->numbers[i].ns = tmp;
    }
    
    return pid;
}
```

#### 为什么要递归分配？

```
┌─────────────────────────────────────────────────────────────────┐
│                    为什么需要递归分配                            │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│   原因：父命名空间需要能看到并管理子命名空间的进程              │
│                                                                 │
│   场景：                                                        │
│   ├── 宿主机上执行 ps aux，需要看到容器内的进程                 │
│   ├── 宿主机上执行 kill 12345，需要能杀死容器内进程             │
│   └── 监控系统需要统计所有进程的资源使用                        │
│                                                                 │
│   如果不递归分配：                                              │
│   └── 父命名空间无法识别子命名空间的进程                        │
│       无法管理、无法监控、无法杀死                              │
│                                                                 │
│   可见性规则：                                                  │
│   ┌─────────────────────────────────────────────────────────┐  │
│   │  init_pid_ns (level 0)                                   │  │
│   │  可以看到：所有进程（通过 level 0 的 PID）               │  │
│   │                                                          │  │
│   │  container_ns (level 1)                                  │  │
│   │  可以看到：自己和子命名空间的进程                        │  │
│   │  看不到：父命名空间和兄弟命名空间的进程                  │  │
│   │                                                          │  │
│   │  nested_ns (level 2)                                     │  │
│   │  可以看到：只有自己命名空间的进程                        │  │
│   └─────────────────────────────────────────────────────────┘  │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

#### 获取进程 PID 的过程

```c
// 获取进程在指定命名空间中的 PID
pid_t pid_nr_ns(struct pid *pid, struct pid_namespace *ns)
{
    struct upid *upid;
    
    // 如果进程的层级比目标命名空间浅，返回 0（看不到）
    if (pid->level < ns->level)
        return 0;
    
    // 返回该命名空间对应的 PID
    upid = &pid->numbers[ns->level];
    if (upid->ns == ns)
        return upid->nr;
    
    return 0;
}

// 示例：
// 进程在 level 2 创建，pid->level = 2
// 
// 从 init_pid_ns (level 0) 查询：返回 pid->numbers[0].nr = 12345
// 从 container_ns (level 1) 查询：返回 pid->numbers[1].nr = 50
// 从 nested_ns (level 2) 查询：返回 pid->numbers[2].nr = 1
// 从其他 level 1 命名空间查询：返回 0（看不到）
```

### 4.5 PID 1 的特殊性

每个 PID Namespace 都有自己的 PID 1 进程，它有特殊职责：

```
┌─────────────────────────────────────────────────────────────────┐
│                    PID 1 的特殊性                                │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│   PID 1 = init 进程 = child_reaper（孤儿收割者）                │
│                                                                 │
│   职责：                                                        │
│   1. 收养孤儿进程                                               │
│      └── 当父进程退出，子进程变成孤儿                           │
│          孤儿进程会被 PID 1 收养                                │
│                                                                 │
│   2. 回收僵尸进程                                               │
│      └── PID 1 需要调用 wait() 回收子进程                       │
│          否则会产生僵尸进程                                     │
│                                                                 │
│   3. 信号处理                                                   │
│      └── PID 1 默认忽略未注册的信号                             │
│          防止被意外杀死                                         │
│                                                                 │
│   容器中的问题：                                                │
│   ┌─────────────────────────────────────────────────────────┐  │
│   │  如果容器的 PID 1 是普通应用（如 nginx）：               │  │
│   │  ├── 它可能不会正确处理信号                              │  │
│   │  ├── 它可能不会回收僵尸进程                              │  │
│   │  └── 导致容器内僵尸进程堆积                              │  │
│   │                                                          │  │
│   │  解决方案：                                              │  │
│   │  ├── 使用 tini、dumb-init 等轻量 init                    │  │
│   │  └── 或者应用自己正确处理信号和子进程                    │  │
│   └─────────────────────────────────────────────────────────┘  │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

### 4.6 创建新的 PID Namespace

```
┌─────────────────────────────────────────────────────────────────┐
│                    创建 PID Namespace                            │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│   方式 1：clone() 系统调用                                      │
│                                                                 │
│   pid_t pid = clone(child_func, stack,                          │
│                     CLONE_NEWPID | SIGCHLD, arg);               │
│                                                                 │
│   子进程会在新的 PID Namespace 中，PID = 1                      │
│                                                                 │
│   方式 2：unshare() 系统调用                                    │
│                                                                 │
│   unshare(CLONE_NEWPID);                                        │
│   pid_t pid = fork();  // fork 后子进程在新命名空间，PID = 1    │
│                                                                 │
│   注意：unshare 后当前进程不会进入新命名空间                    │
│         只有后续 fork 的子进程才会                              │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

### 4.7 /proc 文件系统与 PID Namespace

```
┌─────────────────────────────────────────────────────────────────┐
│                    /proc 与 PID Namespace                        │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│   /proc 文件系统显示的是当前 PID Namespace 的进程               │
│                                                                 │
│   宿主机：                        容器内：                      │
│   /proc/                          /proc/                        │
│   ├── 1/     (systemd)            ├── 1/     (nginx)           │
│   ├── 2/     (kthreadd)           ├── 2/     (worker)          │
│   ├── ...                         └── ...                       │
│   ├── 12345/ (nginx in container)                               │
│   └── ...                                                       │
│                                                                 │
│   容器启动时需要重新挂载 /proc：                                │
│   mount -t proc proc /proc                                      │
│                                                                 │
│   这样容器内的 ps、top 等命令才能正确显示                       │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

### 4.8 PID Namespace 的销毁

```
┌─────────────────────────────────────────────────────────────────┐
│                    PID Namespace 销毁                            │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│   当 PID Namespace 中的所有进程都退出时：                       │
│                                                                 │
│   1. PID 1 退出                                                 │
│      └── 该命名空间中的所有其他进程收到 SIGKILL                 │
│                                                                 │
│   2. 所有进程退出后                                             │
│      └── 命名空间被销毁，资源被回收                             │
│                                                                 │
│   这就是为什么容器的主进程退出，整个容器就停止了                │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

---

## 5. 总结

### 5.1 容器 = Namespace + Cgroup + rootfs

```
┌─────────────────────────────────────────────────────────────────┐
│                    容器的三大支柱                                │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│   ┌─────────────────────────────────────────────────────────┐  │
│   │                      容器                                │  │
│   │                                                          │  │
│   │   ┌─────────────┐  ┌─────────────┐  ┌─────────────┐     │  │
│   │   │  Namespace  │  │   Cgroup    │  │   rootfs    │     │  │
│   │   │   （隔离）  │  │  （限制）   │  │ （文件系统）│     │  │
│   │   │             │  │             │  │             │     │  │
│   │   │ 看到什么    │  │ 能用多少    │  │ 根目录是啥  │     │  │
│   │   │ PID/Net/... │  │ CPU/Mem/... │  │ 镜像层叠加  │     │  │
│   │   └─────────────┘  └─────────────┘  └─────────────┘     │  │
│   │                                                          │  │
│   └─────────────────────────────────────────────────────────┘  │
│                                                                 │
│   容器本质上就是一个：                                          │
│   ├── 被 Namespace 隔离                                         │
│   ├── 被 Cgroup 限制                                            │
│   └── 使用特定 rootfs 的进程                                    │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

### 5.2 关键概念回顾

```
┌─────────────────────────────────────────────────────────────────┐
│                    关键概念                                      │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│   虚拟机 vs 容器：                                              │
│   ├── 虚拟机：硬件级虚拟化，独立内核，重量级                    │
│   └── 容器：进程级隔离，共享内核，轻量级                        │
│                                                                 │
│   Namespace：                                                   │
│   ├── 隔离系统资源的视图                                        │
│   ├── 8 种类型：PID、Net、Mount、UTS、IPC、User、Cgroup、Time   │
│   └── 让进程以为自己独占系统                                    │
│                                                                 │
│   Cgroup：                                                      │
│   ├── 限制进程能使用的资源                                      │
│   ├── CPU、内存、IO、进程数等                                   │
│   └── 防止容器耗尽宿主机资源                                    │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

---

*持续更新中...*
