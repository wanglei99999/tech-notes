# Linux 用户态协程

> 📖 参考书籍：《深入理解 Linux 进程与内存》
>
> 🤖 笔记方式：阅读书籍 + AI 辅助答疑整理
>
> 本文探讨用户态协程的实现原理，以 Go 语言的 GMP 模型为例，理解协程与内核线程的关系。

## 目录

1. [M - Machine（线程）](#1-m---machine线程)
2. [G - Goroutine（协程）](#2-g---goroutine协程)
3. [P - Processor（虚拟处理器）](#3-p---processor虚拟处理器)
4. [Go 程序启动与 GMP 初始化](#4-go-程序启动与-gmp-初始化)
5. [栈内存管理](#5-栈内存管理)
6. [网络轮询器（Netpoller）](#6-网络轮询器netpoller)
7. [GMP 调度流程](#7-gmp-调度流程)
8. [与内核调度的对比](#8-与内核调度的对比)

---

## 1. M - Machine（线程）

### 1.1 什么是 M？

M 是 Machine 的缩写，代表**操作系统的内核线程**，是真正执行代码的载体。

```
┌─────────────────────────────────────────────────────────────────┐
│                        M 的本质                                  │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│   M = 内核线程（Kernel Thread）                                 │
│                                                                 │
│   ├── 由操作系统创建和调度                                      │
│   ├── 对应 Linux 中的 task_struct                               │
│   ├── 被内核的 CFS 调度器调度到 CPU 上执行                      │
│   └── Go 运行时通过 clone() 系统调用创建                        │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

### 1.2 为什么从 M 开始讲？

理解 GMP 模型，必须先理解 M，因为：

```
┌─────────────────────────────────────────────────────────────────┐
│                    M 是执行的基础                                │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│   CPU 只认识内核线程（M），不认识协程（G）                      │
│                                                                 │
│   执行链路：                                                    │
│   G（协程）──依附于──→ M（线程）──被调度到──→ CPU              │
│                                                                 │
│   没有 M，G 就无法执行                                          │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

### 1.3 M 的特点

| 特性 | 说明 |
|------|------|
| 创建方式 | Go 运行时按需创建（clone 系统调用） |
| 数量限制 | 默认最多 10000 个（可通过 debug.SetMaxThreads 调整） |
| 生命周期 | 可复用，空闲时休眠而非销毁 |
| 与 P 的关系 | M 必须绑定 P 才能执行 G |

### 1.4 M 的状态

```
┌─────────────────────────────────────────────────────────────────┐
│                       M 的状态                                   │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│   自旋中（Spinning）                                            │
│   └── M 绑定了 P，正在寻找可运行的 G                            │
│                                                                 │
│   执行中（Executing）                                           │
│   └── M 正在执行某个 G                                          │
│                                                                 │
│   系统调用中（Syscall）                                         │
│   └── M 正在执行系统调用，被内核阻塞                            │
│                                                                 │
│   休眠中（Idle）                                                │
│   └── M 没有 P，在空闲线程列表中等待                            │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

### 1.5 M 的初始化

M 的创建需要**内核态和用户态配合**完成：

```
┌─────────────────────────────────────────────────────────────────┐
│                      M 的初始化流程                              │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│   【用户态部分】Go 运行时                                       │
│   ├── 1. 分配 m 结构体（用户态内存）                            │
│   ├── 2. 初始化 m 的字段（g0、信号栈等）                        │
│   ├── 3. 分配 g0（M 的调度协程）                                │
│   └── 4. 调用 clone() 系统调用                                  │
│                    ↓                                            │
│   ════════════════════════════════════════════════════════════ │
│                    ↓                                            │
│   【内核态部分】Linux 内核                                      │
│   ├── 5. 创建 task_struct（内核线程描述符）                     │
│   ├── 6. 分配内核栈（通常 8KB）                                 │
│   ├── 7. 设置线程的各种属性                                     │
│   ├── 8. 加入调度器的运行队列                                   │
│   └── 9. 返回用户态                                             │
│                    ↓                                            │
│   ════════════════════════════════════════════════════════════ │
│                    ↓                                            │
│   【用户态部分】继续                                            │
│   └── 10. M 开始执行调度循环 schedule()                         │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

**关键点**：M 的创建涉及系统调用，开销较大（微秒级）。

```go
// runtime/proc.go（简化版）
func newm(fn func(), _p_ *p) {
    // 1. 分配 m 结构体
    mp := allocm(_p_, fn)
    
    // 2. 设置要绑定的 P
    mp.nextp.set(_p_)
    
    // 3. 创建系统线程（调用 clone）
    newm1(mp)
}

func newm1(mp *m) {
    // 调用 clone() 系统调用创建内核线程
    // 新线程从 mstart 开始执行
    newosproc(mp)
}
```

---

## 2. G - Goroutine（协程）

### 2.1 什么是 G？

G 是 Goroutine 的缩写，是 Go 语言中的**用户态协程**。

```
┌─────────────────────────────────────────────────────────────────┐
│                        G 的本质                                  │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│   G = 用户态的轻量级执行单元                                    │
│                                                                 │
│   ├── 由 Go 运行时创建和调度（不是内核）                        │
│   ├── 用 go func() 语法创建                                     │
│   ├── 包含：栈、程序计数器（PC）、状态等                        │
│   └── 非常轻量，可以创建数百万个                                │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

### 2.2 为什么需要 G？

**问题：内核线程的局限性**

```
场景：Web 服务器处理 10000 个并发连接

方案 1：每个连接一个线程（M）
├── 10000 个内核线程
├── 内存：10000 × 8KB（内核栈）= 80MB（仅栈空间）
├── 切换开销：内核态切换，每次约 1-10 微秒
├── 创建开销：系统调用，较慢
└── 问题：资源消耗大，切换开销高，创建慢

方案 2：每个连接一个协程（G）
├── 10000 个 Goroutine
├── 内存：10000 × 2KB（初始栈）= 20MB
├── 切换开销：用户态切换，每次约 100-200 纳秒
├── 创建开销：用户态操作，非常快
└── 优势：资源消耗小，切换快，创建快
```

### 2.3 G 的结构

```go
// runtime/runtime2.go（简化版）
type g struct {
    stack       stack   // 栈内存范围 [stack.lo, stack.hi)
    stackguard0 uintptr // 栈溢出检查
    
    m           *m      // 当前绑定的 M（nil 表示未运行）
    sched       gobuf   // 调度信息（PC、SP 等）
    
    atomicstatus uint32 // G 的状态
    goid         int64  // G 的唯一 ID
    
    preempt      bool   // 抢占标志
    // ...
}

// 调度上下文
type gobuf struct {
    sp   uintptr  // 栈指针
    pc   uintptr  // 程序计数器
    g    guintptr // 指向 G 自己
    bp   uintptr  // 基址指针（用于栈回溯）
    // ...
}
```

### 2.4 G 的栈

G 的栈是**动态增长**的，这是它轻量的关键：

```
┌─────────────────────────────────────────────────────────────────┐
│                      G 的动态栈                                  │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│   内核线程栈（固定）          Goroutine 栈（动态）              │
│   ┌──────────────┐           ┌──────────────┐                  │
│   │              │           │              │                  │
│   │    8 KB      │           │   初始 2KB   │ ← 可增长         │
│   │   （固定）   │           │              │                  │
│   │              │           ├──────────────┤                  │
│   │              │           │   按需扩展   │                  │
│   │              │           │   最大 1GB   │                  │
│   └──────────────┘           └──────────────┘                  │
│                                                                 │
│   栈增长机制：                                                  │
│   1. 函数调用时检查 stackguard0                                 │
│   2. 栈空间不足时触发 morestack                                 │
│   3. 分配新的更大的栈（通常 2 倍）                              │
│   4. 复制旧栈内容到新栈                                         │
│   5. 调整栈上的指针                                             │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

### 2.5 G 的状态

```
┌─────────────────────────────────────────────────────────────────┐
│                      G 的状态转换                                │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│   _Gidle（空闲）                                                │
│       │  刚从空闲列表获取，未初始化                             │
│       ↓                                                         │
│   _Gdead（死亡）                                                │
│       │  初始化或执行完毕后的状态                               │
│       ↓                                                         │
│   _Grunnable（可运行）                                          │
│       │  在运行队列中等待被调度                                 │
│       ↓                                                         │
│   _Grunning（运行中）                                           │
│       │  正在某个 M 上执行                                      │
│       │                                                         │
│       ├──→ _Gwaiting（等待中）                                  │
│       │       等待某个条件（channel、锁、I/O 等）               │
│       │       条件满足后回到 _Grunnable                         │
│       │                                                         │
│       ├──→ _Gsyscall（系统调用）                                │
│       │       正在执行系统调用                                  │
│       │       返回后回到 _Grunnable                             │
│       │                                                         │
│       └──→ _Gdead（死亡）                                       │
│               执行完毕，可被复用                                │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

### 2.6 G 的初始化

G 的创建**完全在用户态**完成，不需要系统调用：

```
┌─────────────────────────────────────────────────────────────────┐
│                      G 的初始化流程                              │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│   【全程用户态】Go 运行时                                       │
│                                                                 │
│   go func() { ... }                                             │
│            ↓                                                    │
│   1. 尝试从 P 的 gFree 列表获取空闲 G（复用）                   │
│            ↓                                                    │
│   2. 如果没有空闲 G，分配新的 g 结构体                          │
│            ↓                                                    │
│   3. 分配栈空间（初始 2KB，从用户态内存池）                     │
│            ↓                                                    │
│   4. 设置 G 的字段：                                            │
│      ├── sched.pc = 函数入口地址                                │
│      ├── sched.sp = 栈顶指针                                    │
│      ├── gopc = 调用者的 PC（用于 traceback）                   │
│      └── startpc = 要执行的函数                                 │
│            ↓                                                    │
│   5. 设置状态为 _Grunnable                                      │
│            ↓                                                    │
│   6. 放入 P 的本地队列（优先放 runnext）                        │
│                                                                 │
│   【注意】全程没有系统调用！                                    │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

**关键点**：G 的创建非常快（纳秒级），因为不涉及内核。

```go
// runtime/proc.go（简化版）
func newproc(fn *funcval) {
    // 获取调用者的 PC
    pc := getcallerpc()
    
    // 在 g0 栈上执行（避免栈增长）
    systemstack(func() {
        newg := newproc1(fn, pc)
        
        // 放入当前 P 的运行队列
        runqput(_p_, newg, true)
    })
}

func newproc1(fn *funcval, callerpc uintptr) *g {
    _p_ := getg().m.p.ptr()
    
    // 1. 尝试获取空闲 G
    newg := gfget(_p_)
    if newg == nil {
        // 2. 没有空闲的，创建新的
        newg = malg(_StackMin)  // _StackMin = 2KB
    }
    
    // 3. 初始化 G 的调度信息
    newg.sched.sp = sp
    newg.sched.pc = abi.FuncPCABI0(goexit) + 1
    newg.sched.g = guintptr(unsafe.Pointer(newg))
    newg.gopc = callerpc
    newg.startpc = fn.fn
    
    // 4. 设置状态
    casgstatus(newg, _Gdead, _Grunnable)
    
    return newg
}
```

### 2.7 M 与 G 初始化对比

```
┌─────────────────────────────────────────────────────────────────┐
│                  M 与 G 初始化对比                               │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│              M（线程）                    G（协程）             │
│   ┌─────────────────────────┐   ┌─────────────────────────┐    │
│   │                         │   │                         │    │
│   │  用户态：分配 m 结构体  │   │  用户态：分配 g 结构体  │    │
│   │          ↓              │   │          ↓              │    │
│   │  用户态：初始化字段     │   │  用户态：分配栈（2KB）  │    │
│   │          ↓              │   │          ↓              │    │
│   │  ══════════════════════ │   │  用户态：初始化字段     │    │
│   │  内核态：clone()        │   │          ↓              │    │
│   │          ↓              │   │  用户态：放入运行队列   │    │
│   │  内核态：创建 task_struct│   │                         │    │
│   │          ↓              │   │  【完成！】             │    │
│   │  内核态：分配内核栈     │   │                         │    │
│   │          ↓              │   │                         │    │
│   │  内核态：加入调度队列   │   │                         │    │
│   │          ↓              │   │                         │    │
│   │  ══════════════════════ │   │                         │    │
│   │  用户态：开始调度循环   │   │                         │    │
│   │                         │   │                         │    │
│   │  【完成！】             │   │                         │    │
│   └─────────────────────────┘   └─────────────────────────┘    │
│                                                                 │
│   开销：微秒级（系统调用）       开销：纳秒级（纯用户态）       │
│   栈：8KB 内核栈 + 用户栈        栈：2KB（可增长）              │
│   复用：可以，但开销大           复用：高效，有 gFree 列表      │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

**这就是为什么 Goroutine 可以创建数百万个，而线程只能创建数千个。**

---

## 3. P - Processor（虚拟处理器）

### 3.1 什么是 P？

P 是 Processor 的缩写，是 Go 运行时抽象出的**虚拟处理器**。

```
┌─────────────────────────────────────────────────────────────────┐
│                        P 的本质                                  │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│   P = 调度的上下文 + 本地资源                                   │
│                                                                 │
│   ├── 不是真正的 CPU，是逻辑概念                                │
│   ├── 连接 G 和 M 的桥梁                                        │
│   ├── 每个 P 有自己的本地运行队列                               │
│   └── M 必须绑定 P 才能执行 G                                   │
│                                                                 │
│   数量 = GOMAXPROCS（默认等于 CPU 核心数）                      │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

### 3.2 为什么需要 P？

早期 Go（1.0 版本）只有 G 和 M，后来引入 P 解决了几个关键问题：

```
┌─────────────────────────────────────────────────────────────────┐
│                    没有 P 的问题                                 │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│   Go 1.0 架构（只有 G 和 M）：                                  │
│                                                                 │
│   ┌─────────────────────────────────────────────────────────┐  │
│   │                    全局运行队列                          │  │
│   │              ┌───┬───┬───┬───┬───┐                       │  │
│   │              │ G │ G │ G │ G │...│                       │  │
│   │              └───┴───┴───┴───┴───┘                       │  │
│   │                       ↑                                  │  │
│   │                   一把大锁！                              │  │
│   │                       ↓                                  │  │
│   │              M1      M2      M3      M4                  │  │
│   └─────────────────────────────────────────────────────────┘  │
│                                                                 │
│   问题：                                                        │
│   1. 所有 M 竞争同一把锁 → 锁竞争严重                           │
│   2. G 的创建/销毁都要加锁 → 性能瓶颈                           │
│   3. M 之间无法直接传递 G → 负载不均衡                          │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

**引入 P 后的改进**：

```
┌─────────────────────────────────────────────────────────────────┐
│                    P 解决的问题                                  │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│   1. 减少锁竞争                                                 │
│      ├── 每个 P 有自己的本地队列                                │
│      ├── 大部分操作只访问本地队列（无锁）                       │
│      └── 只有本地队列空/满时才访问全局队列                      │
│                                                                 │
│   2. 控制并行度                                                 │
│      ├── P 的数量 = 真正的并行度                                │
│      ├── GOMAXPROCS 控制 P 的数量                               │
│      └── 与 M 的数量解耦（M 可以更多）                          │
│                                                                 │
│   3. 支持 Work Stealing                                         │
│      ├── P 的本地队列空了，可以从其他 P 偷任务                  │
│      └── 实现负载均衡                                           │
│                                                                 │
│   4. 资源本地化                                                 │
│      ├── P 持有 mcache（内存分配缓存）                          │
│      └── 减少内存分配时的锁竞争                                 │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

### 3.3 P 的结构

```go
// runtime/runtime2.go（简化版）
type p struct {
    id          int32
    status      uint32      // P 的状态
    
    m           muintptr    // 绑定的 M（可以为空）
    
    // 本地运行队列（无锁环形队列）
    runqhead    uint32
    runqtail    uint32
    runq        [256]guintptr  // 容量 256
    
    runnext     guintptr    // 下一个优先执行的 G
    
    // 资源缓存
    mcache      *mcache     // 内存分配缓存
    // ...
}
```

### 3.4 P 的本地队列

```
┌─────────────────────────────────────────────────────────────────┐
│                    P 的本地运行队列                              │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│   结构：无锁环形队列，容量 256                                  │
│                                                                 │
│   ┌───┬───┬───┬───┬───┬───┬───┬───┐                            │
│   │ G │ G │ G │   │   │   │ G │ G │                            │
│   └───┴───┴───┴───┴───┴───┴───┴───┘                            │
│         ↑                       ↑                               │
│      runqtail                runqhead                           │
│      (入队)                   (出队)                            │
│                                                                 │
│   特殊位置：runnext                                             │
│   ├── 存放下一个优先执行的 G                                    │
│   └── 新创建的 G 会放在这里（提高局部性）                       │
│                                                                 │
│   队列满了怎么办？                                              │
│   └── 把一半 G 放到全局队列                                     │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

### 3.5 GMP 整体结构

```
┌─────────────────────────────────────────────────────────────────┐
│                      GMP 整体结构                                │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│   ┌─────────────────────────────────────────────────────────┐  │
│   │                    全局运行队列                          │  │
│   │                  Global Run Queue                        │  │
│   │              ┌───┬───┬───┬───┬───┐                       │  │
│   │              │ G │ G │ G │ G │...│                       │  │
│   │              └───┴───┴───┴───┴───┘                       │  │
│   └─────────────────────────────────────────────────────────┘  │
│                              ↓                                  │
│   ┌──────────────────┐  ┌──────────────────┐                   │
│   │       P0         │  │       P1         │  ...              │
│   │  ┌────────────┐  │  │  ┌────────────┐  │                   │
│   │  │Local Queue │  │  │  │Local Queue │  │                   │
│   │  │ G  G  G    │  │  │  │ G  G       │  │                   │
│   │  └────────────┘  │  │  └────────────┘  │                   │
│   │        ↓         │  │        ↓         │                   │
│   │   ┌────────┐     │  │   ┌────────┐     │                   │
│   │   │ 当前 G │     │  │   │ 当前 G │     │                   │
│   │   └────────┘     │  │   └────────┘     │                   │
│   └────────┬─────────┘  └────────┬─────────┘                   │
│            │bindto               │bindto                        │
│            ↓                     ↓                              │
│       ┌────────┐            ┌────────┐                         │
│       │   M0   │            │   M1   │                         │
│       │(线程)  │            │(线程)  │                         │
│       └────────┘            └────────┘                         │
│            ↓                     ↓                              │
│   ════════════════════════════════════════════                 │
│                    操作系统内核调度                              │
│   ════════════════════════════════════════════                 │
│            ↓                     ↓                              │
│       ┌────────┐            ┌────────┐                         │
│       │ CPU 0  │            │ CPU 1  │                         │
│       └────────┘            └────────┘                         │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

---

## 4. Go 程序启动与 GMP 初始化

理解 Go 程序的启动过程，可以更清晰地看到 M、G、P 是如何协同工作的。

### 4.1 启动全景图

```
┌─────────────────────────────────────────────────────────────────┐
│                    Go 程序启动流程                               │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│   ./main（执行 Go 程序）                                        │
│            ↓                                                    │
│   ┌─────────────────────────────────────────────────────────┐  │
│   │  操作系统加载 ELF 文件                                   │  │
│   │  创建进程（第一个内核线程 = m0）                         │  │
│   └─────────────────────────────────────────────────────────┘  │
│            ↓                                                    │
│   ┌─────────────────────────────────────────────────────────┐  │
│   │  _rt0_amd64_linux（汇编入口）                            │  │
│   │       ↓                                                  │  │
│   │  runtime·rt0_go（初始化入口）                            │  │
│   │       ├── 初始化 g0（m0 的调度协程）                     │  │
│   │       ├── 初始化 m0（绑定 g0）                           │  │
│   │       └── 调用 runtime·schedinit()                       │  │
│   └─────────────────────────────────────────────────────────┘  │
│            ↓                                                    │
│   ┌─────────────────────────────────────────────────────────┐  │
│   │  schedinit()                                             │  │
│   │       ├── 初始化各种子系统（内存、GC 等）                │  │
│   │       ├── 创建 P（数量 = GOMAXPROCS）                    │  │
│   │       └── m0 绑定 p0                                     │  │
│   └─────────────────────────────────────────────────────────┘  │
│            ↓                                                    │
│   ┌─────────────────────────────────────────────────────────┐  │
│   │  newproc() 创建 main goroutine                           │  │
│   │       └── 创建 G 执行 runtime.main                       │  │
│   └─────────────────────────────────────────────────────────┘  │
│            ↓                                                    │
│   ┌─────────────────────────────────────────────────────────┐  │
│   │  mstart() 启动调度循环                                   │  │
│   │       └── schedule() → execute(main goroutine)           │  │
│   └─────────────────────────────────────────────────────────┘  │
│            ↓                                                    │
│   ┌─────────────────────────────────────────────────────────┐  │
│   │  runtime.main()                                          │  │
│   │       ├── 启动 sysmon 监控线程                           │  │
│   │       ├── 执行 init() 函数                               │  │
│   │       └── 调用 main.main()（用户代码）                   │  │
│   └─────────────────────────────────────────────────────────┘  │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

### 4.2 m0 和 g0：最初的 M 和 G

Go 程序启动时，有两个特殊的结构：

```
┌─────────────────────────────────────────────────────────────────┐
│                      m0 和 g0                                    │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│   m0（第一个 M）                                                │
│   ├── 不是 Go 运行时创建的，是操作系统创建进程时自带的          │
│   ├── 对应进程的主线程                                          │
│   ├── 全局变量，不需要分配                                      │
│   └── 负责执行初始化和启动调度                                  │
│                                                                 │
│   g0（m0 的调度协程）                                           │
│   ├── 每个 M 都有一个 g0                                        │
│   ├── 不执行用户代码，只执行调度相关代码                        │
│   ├── 栈较大（约 64KB），用于执行 runtime 代码                  │
│   └── 调度时切换到 g0 栈执行 schedule()                         │
│                                                                 │
│   关系：                                                        │
│   ┌──────────┐                                                  │
│   │    m0    │                                                  │
│   │  ┌────┐  │                                                  │
│   │  │ g0 │  │ ← m0 的调度协程                                  │
│   │  └────┘  │                                                  │
│   │    ↓     │                                                  │
│   │  ┌────┐  │                                                  │
│   │  │ G  │  │ ← 当前执行的用户 G                               │
│   │  └────┘  │                                                  │
│   └──────────┘                                                  │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

### 4.3 初始化阶段详解

#### 阶段 1：汇编入口

```asm
// runtime/asm_amd64.s
TEXT _rt0_amd64_linux(SB),NOSPLIT,$-8
    JMP _rt0_amd64(SB)

TEXT _rt0_amd64(SB),NOSPLIT,$-8
    MOVQ 0(SP), DI      // argc
    LEAQ 8(SP), SI      // argv
    JMP  runtime·rt0_go(SB)
```

#### 阶段 2：rt0_go 初始化

```
┌─────────────────────────────────────────────────────────────────┐
│                    rt0_go 做的事情                               │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│   1. 初始化 g0 的栈                                             │
│      ├── 设置 g0.stack.lo 和 g0.stack.hi                        │
│      └── 设置 g0.stackguard0 和 g0.stackguard1                  │
│                                                                 │
│   2. 绑定 m0 和 g0                                              │
│      ├── m0.g0 = &g0                                            │
│      └── g0.m = &m0                                             │
│                                                                 │
│   3. 调用 schedinit() 初始化调度器                              │
│                                                                 │
│   4. 调用 newproc() 创建 main goroutine                         │
│                                                                 │
│   5. 调用 mstart() 启动调度                                     │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

#### 阶段 3：schedinit 调度器初始化

```go
// runtime/proc.go（简化版）
func schedinit() {
    // 1. 获取 g0
    _g_ := getg()
    
    // 2. 设置最大 M 数量
    sched.maxmcount = 10000
    
    // 3. 初始化各种子系统
    stackinit()      // 栈缓存
    mallocinit()     // 内存分配器
    gcinit()         // GC
    
    // 4. 确定 P 的数量
    procs := ncpu    // 默认等于 CPU 核心数
    if n := GOMAXPROCS(0); n > 0 {
        procs = n    // 如果设置了 GOMAXPROCS，使用设置的值
    }
    
    // 5. 创建 P
    procresize(procs)
    
    // 此时：m0 已经绑定了 p0
}
```

#### 阶段 4：创建 P

```
┌─────────────────────────────────────────────────────────────────┐
│                    procresize() 创建 P                           │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│   假设 GOMAXPROCS = 4：                                         │
│                                                                 │
│   1. 创建 4 个 P 结构体                                         │
│      allp = [p0, p1, p2, p3]                                    │
│                                                                 │
│   2. 初始化每个 P                                               │
│      ├── 设置 id                                                │
│      ├── 初始化本地队列                                         │
│      ├── 分配 mcache                                            │
│      └── 设置状态为 _Pidle                                      │
│                                                                 │
│   3. m0 绑定 p0                                                 │
│      ├── m0.p = p0                                              │
│      ├── p0.m = m0                                              │
│      └── p0.status = _Prunning                                  │
│                                                                 │
│   4. 其他 P 放入空闲列表                                        │
│      sched.pidle = p1 → p2 → p3                                 │
│                                                                 │
│   此时的状态：                                                  │
│   ┌────┐                                                        │
│   │ m0 │ bindto → p0 (running)                                  │
│   └────┘                                                        │
│                    p1, p2, p3 (idle，等待 M)                    │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

#### 阶段 5：创建 main goroutine

```go
// runtime/proc.go
func main() {
    // 在 rt0_go 中调用
    newproc(runtime.main)
}
```

```
┌─────────────────────────────────────────────────────────────────┐
│                创建 main goroutine                               │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│   newproc(runtime.main)：                                       │
│   ├── 创建一个新的 G                                            │
│   ├── 设置 G 的入口函数为 runtime.main                          │
│   └── 放入 p0 的本地队列                                        │
│                                                                 │
│   此时的状态：                                                  │
│   ┌────┐         ┌────┐                                         │
│   │ m0 │bindto → │ p0 │                                         │
│   └────┘         └────┘                                         │
│                     │                                           │
│                     ↓                                           │
│                  ┌──────────────┐                               │
│                  │ main G       │                               │
│                  │ (runnable)   │                               │
│                  └──────────────┘                               │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

#### 阶段 6：启动调度

```
┌─────────────────────────────────────────────────────────────────┐
│                    mstart() 启动调度                             │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│   mstart()                                                      │
│       ↓                                                         │
│   mstart1()                                                     │
│       ↓                                                         │
│   schedule()                                                    │
│       │                                                         │
│       ├── 从 p0 的本地队列获取 main G                           │
│       └── execute(main G)                                       │
│               ↓                                                 │
│           gogo(&main_G.sched)                                   │
│               │                                                 │
│               └── 跳转到 runtime.main 执行                      │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

### 4.4 runtime.main 做了什么

```go
// runtime/proc.go（简化版）
func main() {
    // 1. 启动 sysmon 监控线程
    //    sysmon 是独立的 M，不绑定 P
    systemstack(func() {
        newm(sysmon, nil)
    })
    
    // 2. 执行 runtime 包的 init
    runtime_init()
    
    // 3. 启动 GC
    gcenable()
    
    // 4. 执行用户包的 init（按依赖顺序）
    main_init()
    
    // 5. 调用用户的 main 函数
    main_main()  // 就是 main.main()
    
    // 6. main 返回后，退出程序
    exit(0)
}
```

### 4.5 启动后的 GMP 状态

```
┌─────────────────────────────────────────────────────────────────┐
│              Go 程序启动完成后的 GMP 状态                        │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│   假设 4 核 CPU，GOMAXPROCS = 4：                               │
│                                                                 │
│   ┌─────────────────────────────────────────────────────────┐  │
│   │                    全局运行队列（空）                     │  │
│   └─────────────────────────────────────────────────────────┘  │
│                                                                 │
│   ┌────────────┐  ┌────────────┐  ┌────────────┐  ┌──────────┐ │
│   │     P0     │  │     P1     │  │     P2     │  │    P3    │ │
│   │  (running) │  │   (idle)   │  │   (idle)   │  │  (idle)  │ │
│   │ ┌────────┐ │  │            │  │            │  │          │ │
│   │ │ main G │ │  │            │  │            │  │          │ │
│   │ │(running)│ │  │            │  │            │  │          │ │
│   │ └────────┘ │  │            │  │            │  │          │ │
│   └─────┬──────┘  └────────────┘  └────────────┘  └──────────┘ │
│         │                                                       │
│         ↓                                                       │
│   ┌──────────┐                                                  │
│   │    m0    │  ← 主线程，执行 main goroutine                   │
│   └──────────┘                                                  │
│                                                                 │
│   ┌──────────┐                                                  │
│   │  sysmon  │  ← 监控线程，独立 M，不绑定 P                    │
│   └──────────┘                                                  │
│                                                                 │
│   当用户代码执行 go func() 时：                                 │
│   ├── 创建新的 G，放入 P 的本地队列                             │
│   ├── 如果有空闲 P，唤醒或创建 M 来执行                         │
│   └── GMP 调度器开始真正工作                                    │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

### 4.6 小结：启动过程中的 GMP

| 阶段 | M | G | P |
|------|---|---|---|
| 进程创建 | m0（系统创建） | - | - |
| rt0_go | m0 + g0 | g0（调度协程） | - |
| schedinit | m0 | g0 | 创建 P0-Pn |
| newproc | m0 | g0 + main G | P0 绑定 m0 |
| mstart | m0 执行调度 | main G 开始运行 | P0 状态 running |
| runtime.main | m0 + sysmon | main G | P0 |
| 用户 main | 按需创建更多 M | 按需创建更多 G | 按需使用空闲 P |

---

## 5. 栈内存管理

栈内存是理解 M 和 G 性能差异的关键。内核线程和协程在栈的管理方式上有本质区别。

### 5.1 内核线程的栈

内核线程有**两个栈**：用户栈和内核栈。

```
┌─────────────────────────────────────────────────────────────────┐
│                    内核线程的双栈结构                            │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│   用户态                              内核态                    │
│   ┌──────────────────┐               ┌──────────────────┐      │
│   │                  │               │                  │      │
│   │    用户栈        │               │    内核栈        │      │
│   │                  │               │                  │      │
│   │  ┌────────────┐  │               │  ┌────────────┐  │      │
│   │  │ 局部变量   │  │               │  │ 系统调用   │  │      │
│   │  │ 函数参数   │  │               │  │ 中断上下文 │  │      │
│   │  │ 返回地址   │  │               │  │ 内核函数栈 │  │      │
│   │  └────────────┘  │               │  └────────────┘  │      │
│   │                  │               │                  │      │
│   │  大小：8MB       │               │  大小：8KB/16KB  │      │
│   │  （默认，可调）  │               │  （固定）        │      │
│   │                  │               │                  │      │
│   └──────────────────┘               └──────────────────┘      │
│                                                                 │
│   用户栈：执行用户代码时使用                                    │
│   内核栈：执行系统调用、中断处理时使用                          │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

#### 用户栈

```
┌─────────────────────────────────────────────────────────────────┐
│                      用户栈特点                                  │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│   大小：默认 8MB（Linux，可通过 ulimit -s 调整）                │
│                                                                 │
│   分配方式：                                                    │
│   ├── 虚拟内存预留 8MB                                          │
│   ├── 物理内存按需分配（缺页时）                                │
│   └── 有 guard page 防止栈溢出                                  │
│                                                                 │
│   增长方向：从高地址向低地址增长                                │
│                                                                 │
│   ┌────────────────────────┐  高地址                           │
│   │      栈底              │                                   │
│   ├────────────────────────┤                                   │
│   │      已使用            │                                   │
│   │      ↓                 │                                   │
│   │      栈顶（SP）        │                                   │
│   ├────────────────────────┤                                   │
│   │      未使用空间        │                                   │
│   │                        │                                   │
│   ├────────────────────────┤                                   │
│   │      Guard Page        │  ← 访问触发 SIGSEGV               │
│   └────────────────────────┘  低地址                           │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

#### 内核栈

```
┌─────────────────────────────────────────────────────────────────┐
│                      内核栈特点                                  │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│   大小：固定 8KB 或 16KB（取决于内核配置）                      │
│                                                                 │
│   为什么这么小？                                                │
│   ├── 内核栈在物理内存中连续分配                                │
│   ├── 每个线程都需要一个内核栈                                  │
│   ├── 如果太大，内存消耗巨大                                    │
│   └── 内核代码设计时就考虑了栈空间限制                          │
│                                                                 │
│   存放内容：                                                    │
│   ├── thread_info 结构（栈底）                                  │
│   ├── 系统调用参数和返回值                                      │
│   ├── 中断/异常上下文                                           │
│   └── 内核函数调用栈                                            │
│                                                                 │
│   风险：内核栈溢出会导致系统崩溃！                              │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

### 5.2 Goroutine 的栈

Goroutine 只有**一个用户态栈**，而且是**动态增长**的。

```
┌─────────────────────────────────────────────────────────────────┐
│                    Goroutine 栈特点                              │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│   初始大小：2KB（Go 1.4+）                                      │
│   最大大小：1GB（64位系统）                                     │
│   增长方式：动态扩容，按需分配                                  │
│                                                                 │
│   为什么可以这么小？                                            │
│   ├── Go 编译器在函数入口插入栈检查代码                         │
│   ├── 栈不够时自动扩容（不是固定大小）                          │
│   └── 不需要预留大量空间                                        │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

#### 栈增长机制

```
┌─────────────────────────────────────────────────────────────────┐
│                    Goroutine 栈增长                              │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│   【函数调用时的栈检查】                                        │
│                                                                 │
│   func foo() {                                                  │
│       // 编译器插入的检查代码（伪代码）：                       │
│       if SP < stackguard0 {                                     │
│           morestack()  // 栈空间不足，需要扩容                  │
│       }                                                         │
│       // 函数正常代码...                                        │
│   }                                                             │
│                                                                 │
│   【扩容流程】                                                  │
│                                                                 │
│   1. 检测到栈空间不足                                           │
│          ↓                                                      │
│   2. 分配新栈（通常是原来的 2 倍）                              │
│          ↓                                                      │
│   3. 复制旧栈内容到新栈                                         │
│          ↓                                                      │
│   4. 调整栈上的指针（指向栈内的指针需要修正）                   │
│          ↓                                                      │
│   5. 释放旧栈                                                   │
│          ↓                                                      │
│   6. 继续执行                                                   │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

#### 栈扩容示意图

```
┌─────────────────────────────────────────────────────────────────┐
│                    栈扩容过程                                    │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│   扩容前（2KB）              扩容后（4KB）                      │
│   ┌──────────────┐          ┌──────────────┐                   │
│   │   stack.hi   │          │   stack.hi   │                   │
│   ├──────────────┤          ├──────────────┤                   │
│   │              │          │              │                   │
│   │   已使用     │          │              │                   │
│   │              │          │   新增空间   │                   │
│   │   ↓ SP       │          │              │                   │
│   ├──────────────┤          ├──────────────┤                   │
│   │   剩余很少   │  ──→     │   已使用     │  ← 复制过来       │
│   ├──────────────┤          │              │                   │
│   │ stackguard0  │          │   ↓ SP       │                   │
│   ├──────────────┤          ├──────────────┤                   │
│   │   stack.lo   │          │   更多空间   │                   │
│   └──────────────┘          ├──────────────┤                   │
│                             │ stackguard0  │                   │
│        2KB                  ├──────────────┤                   │
│                             │   stack.lo   │                   │
│                             └──────────────┘                   │
│                                                                 │
│                                  4KB                            │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

### 5.3 栈收缩

Goroutine 的栈不仅会增长，还会**收缩**：

```
┌─────────────────────────────────────────────────────────────────┐
│                    栈收缩机制                                    │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│   触发时机：GC 扫描时                                           │
│                                                                 │
│   收缩条件：                                                    │
│   ├── 栈使用量 < 栈容量的 1/4                                   │
│   └── 收缩后的大小 >= 初始大小（2KB）                           │
│                                                                 │
│   收缩流程：                                                    │
│   1. GC 扫描发现栈使用率很低                                    │
│   2. 分配更小的新栈（通常是原来的 1/2）                         │
│   3. 复制栈内容                                                 │
│   4. 调整指针                                                   │
│   5. 释放旧栈                                                   │
│                                                                 │
│   目的：回收不再需要的内存                                      │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

### 5.4 M 与 G 栈对比

```
┌─────────────────────────────────────────────────────────────────┐
│                  M 与 G 栈内存对比                               │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│              M（内核线程）              G（Goroutine）           │
│   ┌─────────────────────────┐   ┌─────────────────────────┐    │
│   │                         │   │                         │    │
│   │  用户栈：8MB（虚拟）    │   │  用户栈：2KB 起         │    │
│   │  内核栈：8KB（物理）    │   │  （动态增长到 1GB）     │    │
│   │                         │   │                         │    │
│   │  总计：~8MB + 8KB       │   │  总计：2KB ~ 1GB        │    │
│   │                         │   │                         │    │
│   └─────────────────────────┘   └─────────────────────────┘    │
│                                                                 │
│   特点对比：                                                    │
│   ┌─────────────────────────────────────────────────────────┐  │
│   │ 特性         │ M（线程）        │ G（协程）            │  │
│   ├─────────────────────────────────────────────────────────┤  │
│   │ 初始大小     │ 8MB + 8KB        │ 2KB                  │  │
│   │ 是否可增长   │ 用户栈可以       │ 是，自动             │  │
│   │ 是否可收缩   │ 否               │ 是，GC 时            │  │
│   │ 内核栈       │ 有（8KB）        │ 无（共享 M 的）      │  │
│   │ 溢出处理     │ SIGSEGV 崩溃     │ 自动扩容             │  │
│   │ 内存效率     │ 低               │ 高                   │  │
│   └─────────────────────────────────────────────────────────┘  │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

### 5.5 为什么 G 不需要内核栈？

```
┌─────────────────────────────────────────────────────────────────┐
│                G 不需要内核栈的原因                              │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│   G 执行系统调用时，使用的是 M 的内核栈：                       │
│                                                                 │
│   ┌────────────────────────────────────────────────────────┐   │
│   │                                                        │   │
│   │   G1 ─────┐                                            │   │
│   │           │                                            │   │
│   │   G2 ─────┼──bindto──→ M ──has──→ 内核栈              │   │
│   │           │                                            │   │
│   │   G3 ─────┘                                            │   │
│   │                                                        │   │
│   │   多个 G 共享同一个 M 的内核栈                         │   │
│   │   （因为同一时刻只有一个 G 在 M 上运行）               │   │
│   │                                                        │   │
│   └────────────────────────────────────────────────────────┘   │
│                                                                 │
│   这就是为什么：                                                │
│   ├── G 可以非常轻量（只需要用户态栈）                          │
│   ├── 创建 G 不需要分配内核资源                                 │
│   └── 可以创建数百万个 G                                        │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

### 5.6 内存消耗对比

```
┌─────────────────────────────────────────────────────────────────┐
│                创建 10000 个并发单元的内存消耗                   │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│   【10000 个线程】                                              │
│   ├── 用户栈：10000 × 8MB = 80GB（虚拟内存）                    │
│   ├── 内核栈：10000 × 8KB = 80MB（物理内存）                    │
│   ├── task_struct：10000 × ~2KB = 20MB                          │
│   └── 总计：~100MB 物理内存 + 80GB 虚拟内存                     │
│                                                                 │
│   【10000 个 Goroutine】                                        │
│   ├── 用户栈：10000 × 2KB = 20MB（初始）                        │
│   ├── g 结构体：10000 × ~400B = 4MB                             │
│   ├── 无内核栈开销                                              │
│   └── 总计：~24MB                                               │
│                                                                 │
│   差距：约 4 倍（物理内存），更重要的是没有内核资源消耗         │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

### 5.7 g0 的特殊栈

每个 M 都有一个 g0，它的栈比较特殊：

```
┌─────────────────────────────────────────────────────────────────┐
│                      g0 的栈                                     │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│   g0 是 M 的调度协程，不执行用户代码                            │
│                                                                 │
│   栈大小：约 64KB（比普通 G 大很多）                            │
│                                                                 │
│   为什么需要这么大？                                            │
│   ├── 执行 runtime 代码（调度、GC 等）                          │
│   ├── 这些代码可能有较深的调用栈                                │
│   └── g0 的栈不会动态增长（避免调度时的复杂性）                 │
│                                                                 │
│   使用场景：                                                    │
│   ├── schedule() 调度循环                                       │
│   ├── GC 相关操作                                               │
│   ├── 栈扩容/收缩操作                                           │
│   └── 系统调用前后的处理                                        │
│                                                                 │
│   ┌──────────┐                                                  │
│   │    M     │                                                  │
│   │  ┌────┐  │                                                  │
│   │  │ g0 │  │ ← 64KB 栈，执行 runtime 代码                     │
│   │  └────┘  │                                                  │
│   │    ↕     │  ← 切换                                          │
│   │  ┌────┐  │                                                  │
│   │  │ G  │  │ ← 2KB+ 栈，执行用户代码                          │
│   │  └────┘  │                                                  │
│   └──────────┘                                                  │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

---

## 6. 网络轮询器（Netpoller）

Go 的高并发网络能力来自于对 epoll 的封装。Netpoller 让 Goroutine 可以用同步的方式写网络代码，底层却是异步非阻塞的。

### 6.1 传统网络编程的问题

```
┌─────────────────────────────────────────────────────────────────┐
│                    传统网络编程模型                              │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│   【阻塞 I/O + 多线程】                                         │
│                                                                 │
│   每个连接一个线程：                                            │
│   ┌────────┐  ┌────────┐  ┌────────┐                           │
│   │ 线程 1 │  │ 线程 2 │  │ 线程 3 │  ...                      │
│   │  ↓     │  │  ↓     │  │  ↓     │                           │
│   │ read() │  │ read() │  │ read() │  ← 阻塞等待数据           │
│   │ 阻塞中 │  │ 阻塞中 │  │ 阻塞中 │                           │
│   └────────┘  └────────┘  └────────┘                           │
│                                                                 │
│   问题：                                                        │
│   ├── 10000 连接 = 10000 线程                                   │
│   ├── 内存消耗大（每线程 8MB 栈）                               │
│   ├── 线程切换开销大                                            │
│   └── 大部分线程在阻塞等待，浪费资源                            │
│                                                                 │
│   【非阻塞 I/O + epoll】                                        │
│                                                                 │
│   单线程处理多连接：                                            │
│   ┌─────────────────────────────────────────────────────────┐  │
│   │                      epoll                               │  │
│   │  ┌─────┐ ┌─────┐ ┌─────┐ ┌─────┐                        │  │
│   │  │ fd1 │ │ fd2 │ │ fd3 │ │ ... │  ← 监控多个 fd         │  │
│   │  └─────┘ └─────┘ └─────┘ └─────┘                        │  │
│   │              ↓                                           │  │
│   │         epoll_wait()                                     │  │
│   │              ↓                                           │  │
│   │         返回就绪的 fd                                    │  │
│   │              ↓                                           │  │
│   │         处理就绪的连接                                   │  │
│   └─────────────────────────────────────────────────────────┘  │
│                                                                 │
│   优点：少量线程处理大量连接                                    │
│   缺点：回调地狱，代码复杂                                      │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

### 6.2 Go 的解决方案：Netpoller

Go 结合了两种模型的优点：**同步编程模型 + 异步底层实现**。

```
┌─────────────────────────────────────────────────────────────────┐
│                    Go 的网络模型                                 │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│   用户代码（同步风格，简单易懂）：                              │
│   ┌─────────────────────────────────────────────────────────┐  │
│   │  conn, _ := net.Dial("tcp", "example.com:80")           │  │
│   │  data := make([]byte, 1024)                             │  │
│   │  n, _ := conn.Read(data)  // 看起来是阻塞的             │  │
│   │  // 处理数据...                                         │  │
│   └─────────────────────────────────────────────────────────┘  │
│                              ↓                                  │
│   Go Runtime（Netpoller）：                                     │
│   ┌─────────────────────────────────────────────────────────┐  │
│   │  1. 设置 fd 为非阻塞模式                                │  │
│   │  2. 尝试 read()                                         │  │
│   │  3. 如果返回 EAGAIN（数据未就绪）：                     │  │
│   │     ├── 将 fd 注册到 epoll                              │  │
│   │     ├── 将当前 G 挂起（gopark）                         │  │
│   │     └── 切换到其他 G 执行                               │  │
│   │  4. 当数据就绪时：                                      │  │
│   │     ├── epoll 返回就绪的 fd                             │  │
│   │     ├── 找到对应的 G                                    │  │
│   │     └── 唤醒 G（goready）                               │  │
│   └─────────────────────────────────────────────────────────┘  │
│                              ↓                                  │
│   底层（Linux epoll）：                                         │
│   ┌─────────────────────────────────────────────────────────┐  │
│   │  epoll_create() → epoll_ctl() → epoll_wait()            │  │
│   └─────────────────────────────────────────────────────────┘  │
│                                                                 │
│   效果：                                                        │
│   ├── 用户写同步代码，简单直观                                  │
│   ├── 底层异步非阻塞，高效                                      │
│   └── G 阻塞时不阻塞 M，M 可以执行其他 G                        │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

### 6.3 Netpoller 的核心结构

```go
// runtime/netpoll.go

// 全局的 epoll fd
var epfd int32 = -1

// pollDesc 描述一个被监控的 fd
type pollDesc struct {
    link *pollDesc  // 链表
    fd   uintptr    // 文件描述符
    
    // 等待读/写的 G
    rg uintptr      // 等待读的 G（或 pdReady/pdWait）
    wg uintptr      // 等待写的 G
    
    // 关联的网络连接
    // ...
}
```

```
┌─────────────────────────────────────────────────────────────────┐
│                    pollDesc 结构                                 │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│   每个网络连接都有一个 pollDesc：                               │
│                                                                 │
│   ┌─────────────────────────────────────────────────────────┐  │
│   │  pollDesc                                                │  │
│   │  ┌─────────────────────────────────────────────────┐    │  │
│   │  │  fd: 5                    // socket fd           │    │  │
│   │  │  rg: G1                   // 等待读的 Goroutine  │    │  │
│   │  │  wg: nil                  // 等待写的 Goroutine  │    │  │
│   │  └─────────────────────────────────────────────────┘    │  │
│   └─────────────────────────────────────────────────────────┘  │
│                                                                 │
│   rg/wg 的状态：                                                │
│   ├── 0：没有 G 在等待                                          │
│   ├── pdReady：I/O 已就绪，G 可以继续                           │
│   ├── pdWait：正在等待 I/O                                      │
│   └── G 指针：具体等待的 Goroutine                              │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

### 6.4 Netpoller 初始化

```go
// runtime/netpoll_epoll.go
func netpollinit() {
    // 创建 epoll 实例
    epfd = epollcreate1(_EPOLL_CLOEXEC)
    
    // 创建一个 pipe 用于唤醒 epoll_wait
    // （当有新的 fd 需要监控时）
}
```

### 6.5 Socket 操作与 Netpoller

课本详细介绍了 Go 如何封装 socket 的各个操作。每个操作都遵循相同的模式：**先尝试非阻塞调用，失败则注册到 epoll 并挂起 G**。

#### Listen（监听）

```
┌─────────────────────────────────────────────────────────────────┐
│                    net.Listen() 流程                             │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│   ln, _ := net.Listen("tcp", ":8080")                           │
│            ↓                                                    │
│   1. socket() 创建 socket fd                                    │
│            ↓                                                    │
│   2. setNonblock(fd) 设置为非阻塞                               │
│            ↓                                                    │
│   3. bind(fd, addr) 绑定地址                                    │
│            ↓                                                    │
│   4. listen(fd, backlog) 开始监听                               │
│            ↓                                                    │
│   5. netpollopen(fd, pd) 注册到 epoll                           │
│      └── epoll_ctl(EPOLL_CTL_ADD, fd, EPOLLIN|EPOLLOUT|EPOLLET) │
│            ↓                                                    │
│   6. 返回 Listener 对象                                         │
│                                                                 │
│   注意：Listen 本身不会阻塞，只是准备好监听                     │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

#### Accept（接受连接）

```
┌─────────────────────────────────────────────────────────────────┐
│                    Listener.Accept() 流程                        │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│   conn, _ := ln.Accept()                                        │
│            ↓                                                    │
│   ┌─────────────────────────────────────────────────────────┐  │
│   │  1. 调用 accept4(fd, SOCK_NONBLOCK)                     │  │
│   │     尝试非阻塞 accept                                   │  │
│   └─────────────────────────────────────────────────────────┘  │
│            ↓                                                    │
│   ┌─────────────────────────────────────────────────────────┐  │
│   │  2. 如果有连接：                                        │  │
│   │     ├── 得到新的 conn_fd（已经是非阻塞的）              │  │
│   │     ├── netpollopen(conn_fd, pd) 注册到 epoll           │  │
│   │     └── 返回 Conn 对象                                  │  │
│   │                                                         │  │
│   │     如果返回 EAGAIN（没有连接）：                       │  │
│   │     └── 继续 ↓                                          │  │
│   └─────────────────────────────────────────────────────────┘  │
│            ↓                                                    │
│   ┌─────────────────────────────────────────────────────────┐  │
│   │  3. runtime.pollWait(pd, 'r')                           │  │
│   │     ├── pd.rg = 当前 G                                  │  │
│   │     └── gopark() 挂起当前 G                             │  │
│   └─────────────────────────────────────────────────────────┘  │
│            ↓                                                    │
│   ┌─────────────────────────────────────────────────────────┐  │
│   │  4. 等待新连接到来...                                   │  │
│   │     epoll 检测到 listen_fd 可读                         │  │
│   │     netpollready() 唤醒 G                               │  │
│   └─────────────────────────────────────────────────────────┘  │
│            ↓                                                    │
│   ┌─────────────────────────────────────────────────────────┐  │
│   │  5. G 被唤醒，重新调用 accept4()                        │  │
│   │     这次成功，返回新连接                                │  │
│   └─────────────────────────────────────────────────────────┘  │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

#### Read（读取数据）

```
┌─────────────────────────────────────────────────────────────────┐
│                    conn.Read() 流程                              │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│   n, _ := conn.Read(buf)                                        │
│            ↓                                                    │
│   ┌─────────────────────────────────────────────────────────┐  │
│   │  1. 调用 syscall.Read(fd, buf)                          │  │
│   │     fd 是非阻塞的                                       │  │
│   └─────────────────────────────────────────────────────────┘  │
│            ↓                                                    │
│   ┌─────────────────────────────────────────────────────────┐  │
│   │  2. 如果有数据：直接返回读取的字节数                    │  │
│   │     如果返回 EAGAIN：数据未就绪，继续 ↓                 │  │
│   └─────────────────────────────────────────────────────────┘  │
│            ↓                                                    │
│   ┌─────────────────────────────────────────────────────────┐  │
│   │  3. runtime.pollWait(pd, 'r')                           │  │
│   │     ├── pd.rg = 当前 G                                  │  │
│   │     └── gopark() 挂起当前 G                             │  │
│   └─────────────────────────────────────────────────────────┘  │
│            ↓                                                    │
│   ┌─────────────────────────────────────────────────────────┐  │
│   │  4. 等待数据到达...                                     │  │
│   │     epoll 检测到 fd 可读（EPOLLIN）                     │  │
│   │     netpollready() 唤醒 G                               │  │
│   └─────────────────────────────────────────────────────────┘  │
│            ↓                                                    │
│   ┌─────────────────────────────────────────────────────────┐  │
│   │  5. G 被唤醒，重新调用 syscall.Read()                   │  │
│   │     这次有数据，读取成功                                │  │
│   └─────────────────────────────────────────────────────────┘  │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

#### Write（写入数据）

```
┌─────────────────────────────────────────────────────────────────┐
│                    conn.Write() 流程                             │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│   n, _ := conn.Write(data)                                      │
│            ↓                                                    │
│   ┌─────────────────────────────────────────────────────────┐  │
│   │  1. 调用 syscall.Write(fd, data)                        │  │
│   │     fd 是非阻塞的                                       │  │
│   └─────────────────────────────────────────────────────────┘  │
│            ↓                                                    │
│   ┌─────────────────────────────────────────────────────────┐  │
│   │  2. 如果写入成功：直接返回写入的字节数                  │  │
│   │     如果返回 EAGAIN：发送缓冲区满，继续 ↓               │  │
│   └─────────────────────────────────────────────────────────┘  │
│            ↓                                                    │
│   ┌─────────────────────────────────────────────────────────┐  │
│   │  3. runtime.pollWait(pd, 'w')                           │  │
│   │     ├── pd.wg = 当前 G  （注意是 wg，不是 rg）          │  │
│   │     └── gopark() 挂起当前 G                             │  │
│   └─────────────────────────────────────────────────────────┘  │
│            ↓                                                    │
│   ┌─────────────────────────────────────────────────────────┐  │
│   │  4. 等待缓冲区可写...                                   │  │
│   │     epoll 检测到 fd 可写（EPOLLOUT）                    │  │
│   │     netpollready() 唤醒 G                               │  │
│   └─────────────────────────────────────────────────────────┘  │
│            ↓                                                    │
│   ┌─────────────────────────────────────────────────────────┐  │
│   │  5. G 被唤醒，重新调用 syscall.Write()                  │  │
│   │     继续写入剩余数据（可能需要多次）                    │  │
│   └─────────────────────────────────────────────────────────┘  │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

#### 四种操作的对比

```
┌─────────────────────────────────────────────────────────────────┐
│                Socket 操作与 Netpoller 对比                      │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│   操作      │ 系统调用        │ 等待事件   │ pollDesc 字段     │
│   ─────────────────────────────────────────────────────────────│
│   Listen    │ socket+bind+    │ -          │ -                 │
│             │ listen          │            │ （不阻塞）        │
│   ─────────────────────────────────────────────────────────────│
│   Accept    │ accept4         │ EPOLLIN    │ pd.rg             │
│             │                 │ （可读）   │                   │
│   ─────────────────────────────────────────────────────────────│
│   Read      │ read            │ EPOLLIN    │ pd.rg             │
│             │                 │ （可读）   │                   │
│   ─────────────────────────────────────────────────────────────│
│   Write     │ write           │ EPOLLOUT   │ pd.wg             │
│             │                 │ （可写）   │                   │
│                                                                 │
│   共同模式：                                                    │
│   1. 设置 fd 为非阻塞                                           │
│   2. 尝试系统调用                                               │
│   3. 如果返回 EAGAIN，注册到 epoll 并挂起 G                     │
│   4. 事件就绪时唤醒 G，重试系统调用                             │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

### 6.6 谁来调用 netpoll？

```
┌─────────────────────────────────────────────────────────────────┐
│                    netpoll 的调用时机                            │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│   1. sysmon 监控线程（定期）                                    │
│      └── 每隔一段时间调用 netpoll(0)（非阻塞）                  │
│          检查是否有就绪的网络 I/O                               │
│                                                                 │
│   2. findrunnable()（调度器找不到 G 时）                        │
│      └── 当 P 的本地队列和全局队列都空时                        │
│          调用 netpoll(block) 阻塞等待网络事件                   │
│          而不是让 M 空转                                        │
│                                                                 │
│   3. startTheWorldWithSema()（GC 结束后）                       │
│      └── GC STW 结束后，检查网络事件                            │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

### 6.7 netpoll 函数

```go
// runtime/netpoll_epoll.go
func netpoll(delay int64) gList {
    // delay < 0: 阻塞等待
    // delay == 0: 非阻塞，立即返回
    // delay > 0: 等待指定时间
    
    var events [128]epollevent
    n := epollwait(epfd, &events[0], 128, waitms)
    
    var toRun gList
    for i := int32(0); i < n; i++ {
        ev := &events[i]
        pd := *(**pollDesc)(unsafe.Pointer(&ev.data))
        
        var mode int32
        if ev.events&(_EPOLLIN|_EPOLLRDHUP|_EPOLLHUP|_EPOLLERR) != 0 {
            mode += 'r'  // 可读
        }
        if ev.events&(_EPOLLOUT|_EPOLLHUP|_EPOLLERR) != 0 {
            mode += 'w'  // 可写
        }
        
        if mode != 0 {
            // 唤醒等待的 G
            netpollready(&toRun, pd, mode)
        }
    }
    
    return toRun  // 返回就绪的 G 列表
}
```

### 6.8 与 GMP 调度的集成

```
┌─────────────────────────────────────────────────────────────────┐
│                Netpoller 与 GMP 的集成                           │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│   ┌─────────────────────────────────────────────────────────┐  │
│   │                    GMP 调度器                            │  │
│   │                                                          │  │
│   │   findrunnable() {                                       │  │
│   │       // 1. 检查本地队列                                 │  │
│   │       // 2. 检查全局队列                                 │  │
│   │       // 3. 从其他 P 偷取                                │  │
│   │       // 4. 检查 netpoll ← 这里！                        │  │
│   │       glist := netpoll(0)                                │  │
│   │       if !glist.empty() {                                │  │
│   │           // 有网络 I/O 就绪的 G                         │  │
│   │           injectglist(&glist)  // 放入运行队列           │  │
│   │       }                                                  │  │
│   │       // 5. 如果还是没有，阻塞在 netpoll                 │  │
│   │       glist := netpoll(block)                            │  │
│   │   }                                                      │  │
│   │                                                          │  │
│   └─────────────────────────────────────────────────────────┘  │
│                              ↕                                  │
│   ┌─────────────────────────────────────────────────────────┐  │
│   │                    Netpoller                             │  │
│   │                                                          │  │
│   │   ┌─────────────────────────────────────────────────┐   │  │
│   │   │              epoll 实例                          │   │  │
│   │   │  ┌──────┐ ┌──────┐ ┌──────┐ ┌──────┐           │   │  │
│   │   │  │ fd:5 │ │ fd:6 │ │ fd:7 │ │ ...  │           │   │  │
│   │   │  │ G1   │ │ G2   │ │ G3   │ │      │           │   │  │
│   │   │  └──────┘ └──────┘ └──────┘ └──────┘           │   │  │
│   │   └─────────────────────────────────────────────────┘   │  │
│   │                                                          │  │
│   └─────────────────────────────────────────────────────────┘  │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

### 6.9 为什么这种设计高效？

```
┌─────────────────────────────────────────────────────────────────┐
│                    Netpoller 的优势                              │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│   1. G 阻塞不阻塞 M                                             │
│      ├── G 等待网络 I/O 时，只是被挂起                          │
│      ├── M 可以继续执行其他 G                                   │
│      └── 不浪费线程资源                                         │
│                                                                 │
│   2. 同步编程模型                                               │
│      ├── 用户写同步代码，逻辑清晰                               │
│      ├── 不需要回调、Promise、async/await                       │
│      └── 错误处理简单                                           │
│                                                                 │
│   3. 底层高效                                                   │
│      ├── 使用 epoll（Linux）/ kqueue（macOS）                   │
│      ├── O(1) 的事件通知                                        │
│      └── 少量线程处理大量连接                                   │
│                                                                 │
│   4. 与调度器深度集成                                           │
│      ├── 网络就绪的 G 直接进入运行队列                          │
│      ├── 没有额外的线程池或事件循环                             │
│      └── 调度开销最小                                           │
│                                                                 │
│   对比：                                                        │
│   ┌─────────────────────────────────────────────────────────┐  │
│   │ 模型              │ 编程复杂度 │ 性能   │ 资源消耗     │  │
│   ├─────────────────────────────────────────────────────────┤  │
│   │ 阻塞 I/O + 多线程 │ 简单       │ 低     │ 高           │  │
│   │ 非阻塞 + 回调     │ 复杂       │ 高     │ 低           │  │
│   │ Go Netpoller      │ 简单       │ 高     │ 低           │  │
│   └─────────────────────────────────────────────────────────┘  │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

### 6.10 小结

```
┌─────────────────────────────────────────────────────────────────┐
│                    Netpoller 要点                                │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│   核心思想：                                                    │
│   ├── 所有网络 fd 设为非阻塞                                    │
│   ├── 用 epoll 统一监控所有 fd                                  │
│   ├── G 等待 I/O 时挂起，不阻塞 M                               │
│   └── I/O 就绪时唤醒对应的 G                                    │
│                                                                 │
│   关键函数：                                                    │
│   ├── netpollinit()：初始化 epoll                               │
│   ├── netpollopen()：将 fd 加入 epoll                           │
│   ├── netpoll()：调用 epoll_wait，返回就绪的 G                  │
│   └── netpollready()：唤醒等待的 G                              │
│                                                                 │
│   与 GMP 的关系：                                               │
│   ├── G 等待网络 → gopark → 挂起                                │
│   ├── 网络就绪 → netpoll → goready → 放入运行队列               │
│   └── 调度器在找不到 G 时会检查 netpoll                         │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

---

## 7. GMP 调度流程

### 7.1 调度循环

每个 M 绑定 P 后，都在执行一个调度循环：

```go
// runtime/proc.go（简化版）
func schedule() {
    _g_ := getg()  // 获取当前 G（g0）
    
    // 1. 每隔一段时间检查全局队列（防止饥饿）
    if _g_.m.p.ptr().schedtick%61 == 0 {
        gp := globrunqget(_g_.m.p.ptr(), 1)
        if gp != nil {
            execute(gp)
            return
        }
    }
    
    // 2. 从本地队列获取
    gp := runqget(_g_.m.p.ptr())
    
    // 3. 本地队列空，尝试其他来源
    if gp == nil {
        gp = findrunnable()  // 会尝试全局队列、偷取、网络轮询
    }
    
    // 4. 执行 G
    execute(gp)
}
```

### 7.2 G 的获取顺序

```
┌─────────────────────────────────────────────────────────────────┐
│                    获取 G 的优先级                               │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│   1. runnext（最高优先级）                                      │
│      └── P 的 runnext 字段，存放刚创建的 G                      │
│                                                                 │
│   2. 本地队列（Local Run Queue）                                │
│      └── P 自己的队列，无锁访问                                 │
│                                                                 │
│   3. 全局队列（Global Run Queue）                               │
│      └── 需要加锁，每 61 次调度检查一次                         │
│                                                                 │
│   4. 网络轮询器（Netpoller）                                    │
│      └── 检查是否有网络 I/O 就绪的 G                            │
│                                                                 │
│   5. Work Stealing（从其他 P 偷取）                             │
│      └── 随机选一个 P，偷取其一半的 G                           │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

### 7.3 Work Stealing（工作窃取）

当一个 P 的本地队列空了，会尝试从其他 P 偷取任务：

```
┌─────────────────────────────────────────────────────────────────┐
│                     Work Stealing                                │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│   P0 (空闲)              P1 (繁忙)                              │
│   ┌──────────┐          ┌──────────┐                           │
│   │ 本地队列 │          │ 本地队列 │                           │
│   │  (空)    │  ←偷取─  │ G G G G  │                           │
│   └──────────┘          └──────────┘                           │
│                                                                 │
│   偷取规则：                                                    │
│   1. 随机选择一个 P（避免总是偷同一个）                         │
│   2. 偷取其本地队列的一半任务                                   │
│   3. 如果所有 P 都空，检查全局队列                              │
│   4. 还是没有，检查网络轮询器                                   │
│   5. 实在没有，M 解绑 P，进入休眠                               │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

### 7.4 系统调用处理

当 G 执行系统调用时，M 会被内核阻塞。Go 运行时的处理：

```
┌─────────────────────────────────────────────────────────────────┐
│                   系统调用处理                                   │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│   【进入系统调用前】                                            │
│   ┌────┐                                                        │
│   │ P0 │ ─bindto─ M0 ─running─ G1                              │
│   └────┘                                                        │
│                                                                 │
│   【进入系统调用】                                              │
│   G1 调用 entersyscall()：                                      │
│   ├── 保存 G1 的上下文                                          │
│   ├── 设置 G1 状态为 _Gsyscall                                  │
│   ├── 设置 P0 状态为 _Psyscall                                  │
│   └── M0 和 P0 暂时解绑（但 P0 还记得 M0）                      │
│                                                                 │
│   【sysmon 检测】                                               │
│   如果系统调用超过 10ms：                                       │
│   ├── sysmon 发现 P0 处于 _Psyscall 太久                        │
│   ├── 把 P0 交给其他空闲的 M（或创建新 M）                      │
│   └── P0 继续调度其他 G，不被 M0 阻塞                           │
│                                                                 │
│   ┌────┐                                                        │
│   │ P0 │ ─handoff─→ M1（接管 P0）                              │
│   └────┘                                                        │
│                      M0 ─syscall─ G1（继续阻塞）                │
│                                                                 │
│   【系统调用返回】                                              │
│   G1 调用 exitsyscall()：                                       │
│   ├── M0 尝试获取 P（优先获取原来的 P0）                        │
│   ├── 如果 P0 被抢走，尝试获取其他空闲 P                        │
│   ├── 如果没有空闲 P，G1 放入全局队列                           │
│   └── M0 进入空闲列表或休眠                                     │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

**关键点**：P 可以被"交接"，不会因为一个 G 的系统调用而阻塞整个 P 的调度。

### 7.5 抢占式调度

Go 1.14 引入了基于信号的抢占式调度：

```
┌─────────────────────────────────────────────────────────────────┐
│                    抢占式调度演进                                │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│   【Go 1.14 之前：协作式抢占】                                  │
│   ├── 在函数调用时检查抢占标志（g.preempt）                     │
│   ├── 如果需要抢占，主动让出                                    │
│   └── 问题：纯计算的死循环无法被抢占                            │
│                                                                 │
│   for {                                                         │
│       // 没有函数调用，永远不会检查抢占标志                     │
│       i++                                                       │
│   }                                                             │
│                                                                 │
│   【Go 1.14+：基于信号的抢占】                                  │
│   ├── sysmon 检测运行超过 10ms 的 G                             │
│   ├── 发送 SIGURG 信号给 M                                      │
│   ├── 信号处理函数保存 G 的上下文                               │
│   └── 将 G 放回队列，调度其他 G                                 │
│                                                                 │
│   优点：即使是死循环也能被抢占                                  │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

### 7.6 sysmon 监控线程

Go 运行时有一个特殊的监控线程 sysmon：

```
┌─────────────────────────────────────────────────────────────────┐
│                      sysmon 的职责                               │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│   sysmon 是一个独立的 M，不绑定 P，周期性执行：                 │
│                                                                 │
│   1. 抢占长时间运行的 G                                         │
│      └── 运行超过 10ms，发送 SIGURG 信号                        │
│                                                                 │
│   2. 回收阻塞的 P                                               │
│      └── 系统调用超过 10ms，将 P 交给其他 M                     │
│                                                                 │
│   3. 网络轮询                                                   │
│      └── 定期检查网络 I/O，唤醒等待的 G                         │
│                                                                 │
│   4. 强制 GC                                                    │
│      └── 超过 2 分钟没有 GC，强制触发                           │
│                                                                 │
│   5. 定时器检查                                                 │
│      └── 检查是否有到期的定时器                                 │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

---

## 8. 与内核调度的对比

### 8.1 两层调度

```
┌─────────────────────────────────────────────────────────────────┐
│                    两层调度架构                                  │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│   ┌─────────────────────────────────────────────────────────┐  │
│   │                    用户态（Go 运行时）                    │  │
│   │                                                          │  │
│   │   G1  G2  G3  G4  G5  G6  ...  Gn                       │  │
│   │    ↓   ↓   ↓   ↓   ↓   ↓       ↓                        │  │
│   │   ┌─────────────────────────────────────────────────┐   │  │
│   │   │           GMP 调度器（用户态）                   │   │  │
│   │   │   决定哪个 G 在哪个 M 上运行                     │   │  │
│   │   └─────────────────────────────────────────────────┘   │  │
│   │                    ↓                                     │  │
│   │              M1    M2    M3    M4                        │  │
│   └─────────────────────────────────────────────────────────┘  │
│                        ↓                                        │
│   ════════════════════════════════════════════════════════════ │
│                        ↓                                        │
│   ┌─────────────────────────────────────────────────────────┐  │
│   │                    内核态（Linux）                        │  │
│   │                                                          │  │
│   │   ┌─────────────────────────────────────────────────┐   │  │
│   │   │           CFS 调度器（内核态）                   │   │  │
│   │   │   决定哪个 M（线程）在哪个 CPU 上运行            │   │  │
│   │   └─────────────────────────────────────────────────┘   │  │
│   │                    ↓                                     │  │
│   │              CPU0  CPU1  CPU2  CPU3                      │  │
│   └─────────────────────────────────────────────────────────┘  │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

### 8.2 关键差异对比

| 特性 | 内核调度（CFS） | Go 调度（GMP） |
|------|----------------|----------------|
| 调度对象 | 线程/进程 | Goroutine |
| 调度位置 | 内核态 | 用户态 |
| 切换开销 | 1-10 微秒 | 100-200 纳秒 |
| 栈大小 | 固定（通常 8KB） | 动态（2KB 起） |
| 数量限制 | 受系统资源限制 | 可达百万级 |
| 抢占方式 | 时钟中断 | 信号 + 协作 |
| 公平性算法 | vruntime 红黑树 | 简单 FIFO + 偷取 |
| 优先级 | 支持（nice 值） | 不支持 |

### 8.3 为什么 Goroutine 切换更快？

```
┌─────────────────────────────────────────────────────────────────┐
│                  切换开销对比                                    │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│   【内核线程切换】（1-10 微秒）                                 │
│   需要做的事情：                                                │
│   ├── 保存所有通用寄存器                                        │
│   ├── 保存浮点寄存器                                            │
│   ├── 保存段寄存器                                              │
│   ├── 切换内核栈                                                │
│   ├── 切换页表（如果是进程切换）                                │
│   ├── 刷新 TLB（如果是进程切换）                                │
│   ├── 用户态 → 内核态 → 用户态                                  │
│   └── 可能触发缓存失效                                          │
│                                                                 │
│   【Goroutine 切换】（100-200 纳秒）                            │
│   需要做的事情：                                                │
│   ├── 保存 PC（程序计数器）                                     │
│   ├── 保存 SP（栈指针）                                         │
│   ├── 保存 BP（基址指针）                                       │
│   ├── 切换 G 结构体指针                                         │
│   └── 全程在用户态完成                                          │
│                                                                 │
│   快 10-100 倍！                                                │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

### 8.4 M:N 调度模型

Go 使用 M:N 调度模型，结合了 1:1 和 N:1 的优点：

```
┌─────────────────────────────────────────────────────────────────┐
│                    调度模型对比                                  │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│   【1:1 模型】（如 Linux pthread、Java）                        │
│   1 个用户线程 = 1 个内核线程                                   │
│   ├── 优点：简单，可利用多核，阻塞不影响其他                    │
│   └── 缺点：创建/切换开销大，数量受限                           │
│                                                                 │
│   【N:1 模型】（如早期 Python、Ruby）                           │
│   N 个用户线程 = 1 个内核线程                                   │
│   ├── 优点：切换快，创建快                                      │
│   └── 缺点：无法利用多核，一个阻塞全部阻塞                      │
│                                                                 │
│   【M:N 模型】（如 Go GMP、Java 21 Virtual Thread）             │
│   M 个用户线程 = N 个内核线程                                   │
│   ├── 优点：切换快 + 可利用多核 + 阻塞不影响其他                │
│   └── 缺点：实现复杂                                            │
│                                                                 │
│   Go 的选择：M:N 模型                                           │
│   ├── G 的数量可以很多（M 个）                                  │
│   ├── M 的数量 ≈ CPU 核心数（N 个）                             │
│   └── P 控制真正的并行度                                        │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

---

## 9. 总结

### 9.1 GMP 核心要点

```
┌─────────────────────────────────────────────────────────────────┐
│                    GMP 核心要点                                  │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│   M（Machine）- 线程                                            │
│   ├── 内核线程，真正执行代码的载体                              │
│   ├── 由 Go 运行时按需创建                                      │
│   └── 必须绑定 P 才能执行 G                                     │
│                                                                 │
│   G（Goroutine）- 协程                                          │
│   ├── 用户态轻量级执行单元                                      │
│   ├── 初始栈 2KB，可动态增长                                    │
│   └── 可以创建数百万个                                          │
│                                                                 │
│   P（Processor）- 虚拟处理器                                    │
│   ├── 调度上下文，连接 G 和 M                                   │
│   ├── 每个 P 有本地运行队列（减少锁竞争）                       │
│   └── 数量 = GOMAXPROCS（控制并行度）                           │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

### 9.2 调度特点

```
┌─────────────────────────────────────────────────────────────────┐
│                    GMP 调度特点                                  │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│   1. Work Stealing                                              │
│      └── P 空闲时从其他 P 偷取任务，实现负载均衡                │
│                                                                 │
│   2. Hand Off                                                   │
│      └── 系统调用时 P 可以交接给其他 M，不阻塞调度              │
│                                                                 │
│   3. 抢占式调度                                                 │
│      └── 基于信号的抢占（Go 1.14+），防止 G 霸占 M              │
│                                                                 │
│   4. sysmon 监控                                                │
│      └── 独立线程监控系统健康，处理抢占、GC、网络等             │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

### 9.3 与内核调度的关系

```
用户态协程调度（GMP）和内核调度（CFS）是两层调度：

┌─────────────────────────────────────────┐
│  GMP 调度器                             │
│  决定：哪个 G 在哪个 M 上运行           │
│  特点：用户态、快速、轻量               │
└─────────────────────────────────────────┘
                    ↓
┌─────────────────────────────────────────┐
│  CFS 调度器                             │
│  决定：哪个 M 在哪个 CPU 上运行         │
│  特点：内核态、公平、完整               │
└─────────────────────────────────────────┘

两者协同工作：
- GMP 在用户态实现高效的协程调度
- CFS 在内核态实现公平的线程调度
- Go 程序的高并发能力来自两层调度的配合
```

---

*持续更新中...*
