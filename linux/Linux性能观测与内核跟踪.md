# Linux 性能观测与内核跟踪

> 📖 参考书籍：《深入理解 Linux 进程与内存》
>
> 🤖 笔记方式：阅读书籍 + AI 辅助答疑整理
>
> 本文介绍 Linux 性能观测技术、内核跟踪机制和火焰图原理。

## 目录

1. [性能观测概述](#1-性能观测概述)
2. [perf 性能分析工具](#2-perf-性能分析工具)
3. [火焰图](#3-火焰图)
4. [内核跟踪技术](#4-内核跟踪技术)
5. [eBPF](#5-ebpf)

---

## 1. 性能观测概述

```
┌─────────────────────────────────────────────────────────────────┐
│                    统计 vs 观测                                  │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│   统计（Statistics）                                            │
│   ├── 被动记录                                                  │
│   ├── 内核自动累计计数器                                        │
│   ├── 数据来源：/proc、/sys                                     │
│   └── 例如：CPU 时间、内存使用量、上下文切换次数                │
│                                                                 │
│   观测（Tracing/Profiling）                                     │
│   ├── 主动探测                                                  │
│   ├── 在特定点插入探针采集数据                                  │
│   ├── 数据来源：探针、采样                                      │
│   └── 例如：函数调用追踪、调用栈采样、延迟分析                  │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

```
┌─────────────────────────────────────────────────────────────────┐
│                    观测技术分类                                  │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│   按数据来源分类：                                              │
│                                                                 │
│   1. 硬件事件（PMU - Performance Monitoring Unit）              │
│      ├── CPU cycles                                             │
│      ├── cache miss / hit                                       │
│      ├── 分支预测失败                                           │
│      └── 内存访问                                               │
│                                                                 │
│   2. 软件事件                                                   │
│      ├── 上下文切换                                             │
│      ├── 缺页异常                                               │
│      ├── CPU 迁移                                               │
│      └── 系统调用                                               │
│                                                                 │
│   3. 静态探针（tracepoint）                                     │
│      └── 内核预埋的观测点                                       │
│                                                                 │
│   4. 动态探针（kprobe/uprobe）                                  │
│      └── 运行时动态插入                                         │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

---

## 2. perf 性能分析工具

### 2.1 perf 简介

```
┌─────────────────────────────────────────────────────────────────┐
│                    perf 是什么                                   │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│   perf 是 Linux 内核自带的性能分析工具                          │
│                                                                 │
│   本质：                                                        │
│   ├── 基于内核 perf_event 子系统                                │
│   ├── 统一的性能事件接口                                        │
│   └── 可采集 CPU、缓存、调用栈等各种事件                        │
│                                                                 │
│   架构：                                                        │
│   ┌─────────────────────────────────────────────────────────┐  │
│   │  用户态：perf 命令行工具                                 │  │
│   │              │                                           │  │
│   │              ↓ perf_event_open() 系统调用                │  │
│   │              │                                           │  │
│   │  内核态：perf_event 子系统                               │  │
│   │              │                                           │  │
│   │      ┌───────┼───────┬───────────────┐                  │  │
│   │      ↓       ↓       ↓               ↓                  │  │
│   │    PMU   软件计数  tracepoint   kprobe/uprobe           │  │
│   │   (硬件)   器                                            │  │
│   └─────────────────────────────────────────────────────────┘  │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

### 2.2 perf 子命令概览

```
┌─────────────────────────────────────────────────────────────────┐
│                    perf 子命令                                   │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│   命令            │ 用途                                        │
│   ─────────────────────────────────────────────────────────────│
│   perf list       │ 列出可用的性能事件                          │
│   perf stat       │ 统计程序的性能指标（计数模式）              │
│   perf record     │ 采样并记录性能数据                          │
│   perf report     │ 分析 record 生成的数据                      │
│   perf script     │ 导出原始采样数据（用于火焰图）              │
│   perf top        │ 实时显示热点函数（类似 top）                │
│   perf probe      │ 动态添加探针（kprobe/uprobe）               │
│   perf trace      │ 类似 strace，跟踪系统调用                   │
│   perf annotate   │ 显示源码/汇编级别的热点                     │
│   perf diff       │ 对比两次采样结果                            │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

### 2.3 perf list - 列出可用事件

```bash
# 列出所有可用事件
perf list

# 按类型过滤
perf list hw          # 硬件事件
perf list sw          # 软件事件
perf list cache       # 缓存事件
perf list tracepoint  # tracepoint 事件

# 搜索特定事件
perf list | grep sched
```

```
┌─────────────────────────────────────────────────────────────────┐
│                    perf list 输出示例                            │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│   Hardware event:                                               │
│     cpu-cycles OR cycles                    # CPU 周期          │
│     instructions                            # 执行的指令数      │
│     cache-references                        # 缓存访问          │
│     cache-misses                            # 缓存未命中        │
│     branch-instructions OR branches         # 分支指令          │
│     branch-misses                           # 分支预测失败      │
│                                                                 │
│   Software event:                                               │
│     cpu-clock                               # CPU 时钟          │
│     task-clock                              # 任务时钟          │
│     page-faults OR faults                   # 缺页              │
│     context-switches OR cs                  # 上下文切换        │
│     cpu-migrations                          # CPU 迁移          │
│                                                                 │
│   Tracepoint event:                                             │
│     sched:sched_switch                      # 进程切换          │
│     sched:sched_wakeup                      # 进程唤醒          │
│     syscalls:sys_enter_read                 # read 系统调用     │
│     block:block_rq_issue                    # 块设备请求        │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

### 2.4 perf stat - 统计性能指标

```bash
# 基本用法：统计程序执行的性能指标
perf stat ./my_program

# 统计指定进程（运行 10 秒）
perf stat -p $PID sleep 10

# 统计所有 CPU（系统级）
perf stat -a sleep 5

# 指定要统计的事件
perf stat -e cycles,instructions,cache-misses ./my_program

# 重复运行多次取平均值
perf stat -r 5 ./my_program

# 详细输出
perf stat -d ./my_program
```

```
┌─────────────────────────────────────────────────────────────────┐
│                    perf stat 输出示例                            │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│   $ perf stat ./my_program                                      │
│                                                                 │
│    Performance counter stats for './my_program':                │
│                                                                 │
│         1,234.56 msec  task-clock        # 0.998 CPUs utilized  │
│              123       context-switches  # 0.100 K/sec          │
│                2       cpu-migrations    # 0.002 K/sec          │
│            5,678       page-faults       # 0.005 M/sec          │
│    3,456,789,012       cycles            # 2.800 GHz            │
│    2,345,678,901       instructions      # 0.68 insn per cycle  │
│      234,567,890       branches          # 190.000 M/sec        │
│       12,345,678       branch-misses     # 5.26% of all branches│
│                                                                 │
│       1.237123456 seconds time elapsed                          │
│       1.234567890 seconds user                                  │
│       0.001234567 seconds sys                                   │
│                                                                 │
│   关键指标解读：                                                │
│   ├── insn per cycle (IPC)：每周期执行指令数，越高越好          │
│   ├── branch-misses：分支预测失败率，高说明分支多或不可预测     │
│   ├── cache-misses：缓存未命中，高说明内存访问模式差            │
│   └── context-switches：上下文切换，高说明调度频繁              │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

### 2.5 perf record - 采样记录

```bash
# 基本用法：采样程序执行
perf record ./my_program

# 采样指定进程
perf record -p $PID sleep 30

# 采样所有 CPU（系统级）
perf record -a sleep 10

# 记录调用栈（重要！生成火焰图必须）
perf record -g ./my_program
perf record -g -p $PID sleep 30

# 指定采样事件
perf record -e cycles -g ./my_program
perf record -e cache-misses -g ./my_program

# 指定采样频率（每秒采样次数）
perf record -F 99 -g ./my_program

# 指定输出文件
perf record -o mydata.perf -g ./my_program

# 采样特定 CPU
perf record -C 0,1 -a sleep 10
```

```
┌─────────────────────────────────────────────────────────────────┐
│                    perf record 常用选项                          │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│   选项              │ 说明                                      │
│   ─────────────────────────────────────────────────────────────│
│   -g                │ 记录调用栈（生成火焰图必须）              │
│   -p PID            │ 采样指定进程                              │
│   -a                │ 采样所有 CPU（系统级）                    │
│   -e EVENT          │ 指定采样事件                              │
│   -F FREQ           │ 采样频率（默认 4000 Hz）                  │
│   -o FILE           │ 输出文件（默认 perf.data）                │
│   -C CPU            │ 指定 CPU                                  │
│   --call-graph dwarf│ 使用 DWARF 信息获取调用栈（更准确）       │
│   --call-graph fp   │ 使用帧指针获取调用栈（需要 -fno-omit-frame-pointer）│
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

### 2.6 perf report - 分析采样数据

```bash
# 基本用法：交互式查看
perf report

# 指定数据文件
perf report -i mydata.perf

# 按调用者排序（caller）
perf report --call-graph caller

# 按被调用者排序（callee）
perf report --call-graph callee

# 显示源码（需要调试信息）
perf report --source

# 不进入交互模式，直接输出
perf report --stdio

# 按进程/线程分组
perf report --sort comm,dso,symbol
```

```
┌─────────────────────────────────────────────────────────────────┐
│                    perf report 交互界面                          │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│   Overhead  Command   Shared Object      Symbol                 │
│   ────────────────────────────────────────────────────────────  │
│    25.00%   my_prog   my_prog            [.] hot_function       │
│    15.00%   my_prog   libc.so.6          [.] malloc             │
│    10.00%   my_prog   my_prog            [.] process_data       │
│     8.00%   my_prog   [kernel.kallsyms]  [k] copy_user_generic  │
│     ...                                                         │
│                                                                 │
│   交互操作：                                                    │
│   ├── Enter：展开/折叠调用栈                                    │
│   ├── +/-：展开/折叠所有                                        │
│   ├── a：annotate，查看汇编级热点                               │
│   ├── s：按符号排序                                             │
│   ├── /：搜索                                                   │
│   └── q：退出                                                   │
│                                                                 │
│   符号说明：                                                    │
│   ├── [.] 用户态函数                                            │
│   └── [k] 内核态函数                                            │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

### 2.7 perf script - 导出原始数据

```bash
# 导出采样数据（用于生成火焰图）
perf script > out.perf

# 指定输出字段
perf script -F comm,pid,tid,time,event,ip,sym,dso

# 只导出特定进程
perf script --pid $PID

# 生成火焰图的完整流程
perf record -g ./my_program
perf script > out.perf
./stackcollapse-perf.pl out.perf > out.folded
./flamegraph.pl out.folded > flamegraph.svg
```

### 2.8 perf top - 实时热点分析

```bash
# 实时查看系统热点（类似 top）
perf top

# 查看指定进程
perf top -p $PID

# 显示调用栈
perf top -g

# 指定事件
perf top -e cache-misses

# 指定采样频率
perf top -F 99
```

```
┌─────────────────────────────────────────────────────────────────┐
│                    perf top 界面                                 │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│   Samples: 10K of event 'cycles', 4000 Hz                       │
│   Overhead  Shared Object       Symbol                          │
│   ────────────────────────────────────────────────────────────  │
│    12.34%  [kernel]             [k] _raw_spin_lock_irqsave      │
│     8.56%  libc.so.6            [.] __memcpy_avx_unaligned      │
│     5.23%  my_program           [.] hot_function                │
│     ...                                                         │
│                                                                 │
│   实时刷新，按 q 退出                                           │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

### 2.9 perf probe - 动态探针

```bash
# 在内核函数上添加探针
perf probe --add do_sys_open

# 在函数特定位置添加探针
perf probe --add 'do_sys_open filename:string'

# 在用户态函数添加探针
perf probe -x /path/to/binary --add my_function

# 列出已添加的探针
perf probe --list

# 删除探针
perf probe --del do_sys_open

# 使用探针采样
perf record -e probe:do_sys_open -a sleep 5
```

### 2.10 perf trace - 系统调用跟踪

```bash
# 跟踪程序的系统调用（类似 strace）
perf trace ./my_program

# 跟踪指定进程
perf trace -p $PID

# 只跟踪特定系统调用
perf trace -e open,read,write ./my_program

# 显示调用栈
perf trace -g ./my_program

# 统计系统调用耗时
perf trace --summary ./my_program
```

### 2.11 常用场景示例

```bash
# 场景 1：找出 CPU 热点函数
perf record -g ./my_program
perf report

# 场景 2：生成火焰图
perf record -F 99 -g -p $PID sleep 30
perf script | ./stackcollapse-perf.pl | ./flamegraph.pl > cpu.svg

# 场景 3：分析缓存性能
perf stat -e cache-references,cache-misses,L1-dcache-loads,L1-dcache-load-misses ./my_program

# 场景 4：分析分支预测
perf stat -e branches,branch-misses ./my_program

# 场景 5：跟踪上下文切换
perf record -e context-switches -g -p $PID sleep 10
perf report

# 场景 6：分析调度延迟
perf record -e sched:sched_switch -a sleep 10
perf script

# 场景 7：对比优化前后
perf record -o before.perf ./my_program_v1
perf record -o after.perf ./my_program_v2
perf diff before.perf after.perf
```

### 2.3 perf 能观测的事件

```
┌─────────────────────────────────────────────────────────────────┐
│                    perf 事件类型                                 │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│   类型              │ 示例                                      │
│   ─────────────────────────────────────────────────────────────│
│   硬件事件          │ cycles, instructions, cache-misses,      │
│   (Hardware)        │ branch-misses, L1-dcache-loads           │
│   ─────────────────────────────────────────────────────────────│
│   软件事件          │ context-switches, page-faults,           │
│   (Software)        │ cpu-migrations, minor-faults             │
│   ─────────────────────────────────────────────────────────────│
│   tracepoint        │ sched:sched_switch, syscalls:*,          │
│                     │ block:block_rq_issue                     │
│   ─────────────────────────────────────────────────────────────│
│   动态探针          │ kprobe, uprobe                           │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

---

## 3. 火焰图

### 3.1 火焰图原理

```
┌─────────────────────────────────────────────────────────────────┐
│                    火焰图是什么                                  │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│   火焰图是调用栈的可视化表示：                                  │
│                                                                 │
│   1. 数据来源：采样调用栈                                       │
│      └── 定时中断，记录当前的完整调用栈                         │
│                                                                 │
│   2. 聚合方式：相同调用路径合并                                 │
│      └── 统计每个调用路径出现的次数                             │
│                                                                 │
│   3. 可视化规则：                                               │
│      ├── 纵向（Y轴）：调用深度，底部是调用者，顶部是被调用者    │
│      ├── 横向（X轴）：时间占比，宽度越宽占用时间越多            │
│      └── 同层左右顺序：无意义（按字母排序）                     │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

### 3.2 火焰图示例

```
假设调用关系：
main() → foo() → a()
main() → foo() → b()
main() → bar() → c()

火焰图表示：
         ┌───a()───┐┌───b()───┐          ┌───c()───┐
         └─────────┘└─────────┘          └─────────┘
    ┌────────foo()─────────────┐    ┌──────bar()───────┐
    └──────────────────────────┘    └──────────────────┘
┌───────────────────────main()─────────────────────────┐
└──────────────────────────────────────────────────────┘

解读：
├── main() 占据整个底部（所有采样都经过 main）
├── foo() 和 bar() 在同一层（都是 main 的直接调用）
├── foo() 比 bar() 宽 → foo() 路径占用更多时间
└── a()、b()、c() 在最顶层（叶子函数）
```

### 3.3 如何看火焰图

```
┌─────────────────────────────────────────────────────────────────┐
│                    火焰图分析技巧                                │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│   关注点：                                                      │
│                                                                 │
│   1. 看"高原"而不是"山峰"                                       │
│      ├── 顶部的宽平台 = 该函数自身消耗大（热点）                │
│      └── 窄尖的山峰 = 只是调用路径，不是瓶颈                    │
│                                                                 │
│   2. 宽度 = 时间占比                                            │
│      ├── 越宽说明该函数（及其子调用）占用时间越多               │
│      └── 优化时优先关注最宽的部分                               │
│                                                                 │
│   3. 同层函数是兄弟关系                                         │
│      ├── 被同一个父函数调用                                     │
│      └── 左右顺序无意义                                         │
│                                                                 │
│   常见模式：                                                    │
│   ├── 顶部很宽 → 叶子函数是热点，考虑优化算法                   │
│   ├── 中间很宽 → 某个中间函数调用次数太多                       │
│   └── 底部分叉多 → 程序有多个独立的执行路径                     │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

### 3.4 生成火焰图

```bash
# 1. 采样调用栈
perf record -g -p $PID -- sleep 30

# 2. 导出为文本
perf script > out.perf

# 3. 折叠调用栈（使用 FlameGraph 工具）
./stackcollapse-perf.pl out.perf > out.folded

# 4. 生成 SVG
./flamegraph.pl out.folded > flamegraph.svg

# 一行命令版本
perf script | ./stackcollapse-perf.pl | ./flamegraph.pl > flamegraph.svg
```

### 3.5 火焰图类型

```
┌─────────────────────────────────────────────────────────────────┐
│                    不同类型的火焰图                              │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│   On-CPU 火焰图                                                 │
│   ├── 采样 CPU 上正在执行的调用栈                               │
│   ├── 分析 CPU 时间花在哪里                                     │
│   └── perf record -g                                            │
│                                                                 │
│   Off-CPU 火焰图                                                │
│   ├── 采样进程阻塞/睡眠时的调用栈                               │
│   ├── 分析等待时间花在哪里（IO、锁等）                          │
│   └── 需要 eBPF 或特殊工具                                      │
│                                                                 │
│   内存火焰图                                                    │
│   ├── 采样内存分配时的调用栈                                    │
│   ├── 分析内存分配热点                                          │
│   └── perf record -e malloc                                     │
│                                                                 │
│   差分火焰图                                                    │
│   ├── 对比两次采样的差异                                        │
│   ├── 红色 = 增加，蓝色 = 减少                                  │
│   └── 用于对比优化前后                                          │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

---

## 4. 内核跟踪技术

### 4.1 静态跟踪：tracepoint

```
┌─────────────────────────────────────────────────────────────────┐
│                    tracepoint 静态探针                           │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│   定义：内核代码中预埋的观测点                                  │
│                                                                 │
│   特点：                                                        │
│   ├── 位置固定（编译时确定）                                    │
│   ├── 接口稳定（内核保证兼容性）                                │
│   ├── 开销小（未启用时几乎为零）                                │
│   └── 覆盖关键路径：调度、系统调用、中断、内存等                │
│                                                                 │
│   位置：                                                        │
│   /sys/kernel/debug/tracing/events/                             │
│   ├── sched/           # 调度相关                               │
│   │   ├── sched_switch                                          │
│   │   ├── sched_wakeup                                          │
│   │   └── ...                                                   │
│   ├── syscalls/        # 系统调用                               │
│   ├── block/           # 块设备                                 │
│   ├── net/             # 网络                                   │
│   └── ...                                                       │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

```bash
# 查看可用的 tracepoint
ls /sys/kernel/debug/tracing/events/

# 启用某个 tracepoint
echo 1 > /sys/kernel/debug/tracing/events/sched/sched_switch/enable

# 查看 trace 输出
cat /sys/kernel/debug/tracing/trace

# 使用 perf 跟踪 tracepoint
perf record -e sched:sched_switch -a sleep 5
```

### 4.2 动态跟踪：kprobe

```
┌─────────────────────────────────────────────────────────────────┐
│                    kprobe 动态探针                               │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│   定义：运行时动态插入到任意内核函数的探针                      │
│                                                                 │
│   类型：                                                        │
│   ├── kprobe    - 函数入口探针                                  │
│   └── kretprobe - 函数返回探针                                  │
│                                                                 │
│   原理：                                                        │
│   ┌─────────────────────────────────────────────────────────┐  │
│   │  1. 保存目标地址的原始指令                               │  │
│   │                                                          │  │
│   │  2. 替换为 breakpoint 指令（x86 上是 int3）              │  │
│   │     ┌──────────────────────────────────────────────┐    │  │
│   │     │  原始：  mov %rdi, %rax                       │    │  │
│   │     │  替换：  int3 (0xCC)                          │    │  │
│   │     └──────────────────────────────────────────────┘    │  │
│   │                                                          │  │
│   │  3. CPU 执行到 int3 时触发异常                           │  │
│   │                                                          │  │
│   │  4. 异常处理程序执行用户注册的 handler                   │  │
│   │                                                          │  │
│   │  5. 单步执行原始指令                                     │  │
│   │                                                          │  │
│   │  6. 恢复正常执行                                         │  │
│   └─────────────────────────────────────────────────────────┘  │
│                                                                 │
│   优点：可以探测任意内核函数                                    │
│   缺点：接口不稳定（内核函数可能变化）                          │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

```bash
# 使用 perf 添加 kprobe
perf probe --add do_sys_open

# 跟踪该探针
perf record -e probe:do_sys_open -a sleep 5

# 删除探针
perf probe --del do_sys_open
```

### 4.3 用户态探针：uprobe

```
┌─────────────────────────────────────────────────────────────────┐
│                    uprobe 用户态探针                             │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│   定义：动态插入到用户态程序的探针                              │
│                                                                 │
│   类型：                                                        │
│   ├── uprobe    - 用户态函数入口                                │
│   └── uretprobe - 用户态函数返回                                │
│                                                                 │
│   原理：与 kprobe 类似                                          │
│   ├── 修改用户态程序的指令                                      │
│   ├── 触发时陷入内核执行 handler                                │
│   └── 然后返回用户态继续执行                                    │
│                                                                 │
│   用途：                                                        │
│   ├── 追踪应用程序的函数调用                                    │
│   ├── 分析库函数的使用情况                                      │
│   └── 无需修改程序源码                                          │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

```bash
# 在 libc 的 malloc 函数上添加 uprobe
perf probe -x /lib/x86_64-linux-gnu/libc.so.6 --add malloc

# 跟踪 malloc 调用
perf record -e probe_libc:malloc -p $PID sleep 5
```

### 4.4 ftrace

```
┌─────────────────────────────────────────────────────────────────┐
│                    ftrace 内核跟踪框架                           │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│   定义：Linux 内核自带的跟踪框架                                │
│                                                                 │
│   主要 tracer：                                                 │
│   ├── function       - 跟踪函数调用                             │
│   ├── function_graph - 跟踪函数调用图（含返回）                 │
│   ├── irqsoff        - 跟踪中断关闭时间                         │
│   ├── preemptoff     - 跟踪抢占关闭时间                         │
│   └── wakeup         - 跟踪进程唤醒延迟                         │
│                                                                 │
│   接口位置：                                                    │
│   /sys/kernel/debug/tracing/                                    │
│   ├── available_tracers    # 可用的 tracer                      │
│   ├── current_tracer       # 当前使用的 tracer                  │
│   ├── trace                # 跟踪输出                           │
│   ├── tracing_on           # 开关                               │
│   └── set_ftrace_filter    # 过滤要跟踪的函数                   │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

```bash
# 查看可用的 tracer
cat /sys/kernel/debug/tracing/available_tracers

# 启用 function_graph tracer
echo function_graph > /sys/kernel/debug/tracing/current_tracer

# 只跟踪特定函数
echo do_sys_open > /sys/kernel/debug/tracing/set_ftrace_filter

# 开始跟踪
echo 1 > /sys/kernel/debug/tracing/tracing_on

# 查看结果
cat /sys/kernel/debug/tracing/trace

# 停止跟踪
echo 0 > /sys/kernel/debug/tracing/tracing_on
```

### 4.5 跟踪技术对比

```
┌─────────────────────────────────────────────────────────────────┐
│                    跟踪技术对比                                  │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│   技术        │ 位置     │ 稳定性 │ 灵活性 │ 开销   │ 用途     │
│   ─────────────────────────────────────────────────────────────│
│   tracepoint  │ 内核预埋 │ 高     │ 低     │ 极低   │ 关键事件 │
│   kprobe      │ 任意内核 │ 低     │ 高     │ 中     │ 深度调试 │
│   uprobe      │ 用户态   │ 低     │ 高     │ 中     │ 应用分析 │
│   ftrace      │ 内核函数 │ 中     │ 中     │ 中     │ 函数跟踪 │
│   perf        │ 统一接口 │ 高     │ 高     │ 低     │ 性能分析 │
│   eBPF        │ 任意     │ 中     │ 极高   │ 低     │ 可编程   │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

---

## 5. eBPF

### 5.1 eBPF 简介

```
┌─────────────────────────────────────────────────────────────────┐
│                    eBPF 是什么                                   │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│   eBPF = extended Berkeley Packet Filter                        │
│                                                                 │
│   本质：内核中的安全沙箱虚拟机                                  │
│                                                                 │
│   特点：                                                        │
│   ├── 可以在内核中运行用户编写的程序                            │
│   ├── 安全：经过验证器检查，不会崩溃内核                        │
│   ├── 高效：JIT 编译为本地机器码                                │
│   └── 灵活：可挂载到各种探针点                                  │
│                                                                 │
│   架构：                                                        │
│   ┌─────────────────────────────────────────────────────────┐  │
│   │  用户态                                                  │  │
│   │  ┌─────────────────────────────────────────────────┐    │  │
│   │  │  BCC / bpftrace / libbpf                         │    │  │
│   │  │  (编写 eBPF 程序的工具)                          │    │  │
│   │  └─────────────────────────────────────────────────┘    │  │
│   │              │ bpf() 系统调用                            │  │
│   │              ↓                                           │  │
│   │  ┌─────────────────────────────────────────────────┐    │  │
│   │  │  eBPF 验证器（检查安全性）                       │    │  │
│   │  └─────────────────────────────────────────────────┘    │  │
│   │              │                                           │  │
│   │              ↓                                           │  │
│   │  ┌─────────────────────────────────────────────────┐    │  │
│   │  │  JIT 编译器（编译为机器码）                      │    │  │
│   │  └─────────────────────────────────────────────────┘    │  │
│   │              │                                           │  │
│   │              ↓                                           │  │
│   │  内核态                                                  │  │
│   │  ┌─────────────────────────────────────────────────┐    │  │
│   │  │  挂载点：kprobe/uprobe/tracepoint/perf_event    │    │  │
│   │  └─────────────────────────────────────────────────┘    │  │
│   └─────────────────────────────────────────────────────────┘  │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

### 5.2 eBPF 工具链

```
┌─────────────────────────────────────────────────────────────────┐
│                    eBPF 工具链                                   │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│   BCC (BPF Compiler Collection)                                 │
│   ├── Python + C 混合编程                                       │
│   ├── 提供大量现成工具                                          │
│   └── 适合复杂场景                                              │
│                                                                 │
│   bpftrace                                                      │
│   ├── 类似 awk 的高级语言                                       │
│   ├── 一行命令即可完成跟踪                                      │
│   └── 适合快速分析                                              │
│                                                                 │
│   libbpf                                                        │
│   ├── C 语言库                                                  │
│   ├── CO-RE (Compile Once, Run Everywhere)                      │
│   └── 适合生产环境                                              │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

### 5.3 bpftrace 示例

```bash
# 跟踪系统调用
bpftrace -e 'tracepoint:syscalls:sys_enter_open { printf("%s %s\n", comm, str(args->filename)); }'

# 统计系统调用次数
bpftrace -e 'tracepoint:syscalls:sys_enter_* { @[probe] = count(); }'

# 跟踪进程调度延迟
bpftrace -e 'tracepoint:sched:sched_switch { @[args->prev_comm] = hist(args->prev_prio); }'

# 函数延迟直方图
bpftrace -e 'kprobe:do_sys_open { @start[tid] = nsecs; }
             kretprobe:do_sys_open /@start[tid]/ { @ns = hist(nsecs - @start[tid]); delete(@start[tid]); }'
```

### 5.4 BCC 常用工具

```
┌─────────────────────────────────────────────────────────────────┐
│                    BCC 工具集                                    │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│   工具            │ 用途                                        │
│   ─────────────────────────────────────────────────────────────│
│   execsnoop       │ 跟踪新进程执行                              │
│   opensnoop       │ 跟踪文件打开                                │
│   biolatency      │ 块设备 IO 延迟直方图                        │
│   tcpconnect      │ 跟踪 TCP 连接                               │
│   tcplife         │ 跟踪 TCP 连接生命周期                       │
│   runqlat         │ CPU 运行队列延迟                            │
│   profile         │ CPU 采样分析                                │
│   offcputime      │ Off-CPU 时间分析                            │
│   funccount       │ 函数调用计数                                │
│   funclatency     │ 函数延迟分析                                │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

---

## 6. 总结

```
┌─────────────────────────────────────────────────────────────────┐
│                    性能观测技术栈                                │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│   层次              │ 技术                                      │
│   ─────────────────────────────────────────────────────────────│
│   可视化            │ 火焰图、热力图                            │
│   ─────────────────────────────────────────────────────────────│
│   前端工具          │ perf、bpftrace、BCC                       │
│   ─────────────────────────────────────────────────────────────│
│   内核框架          │ perf_event、ftrace、eBPF                  │
│   ─────────────────────────────────────────────────────────────│
│   探针机制          │ tracepoint、kprobe、uprobe                │
│   ─────────────────────────────────────────────────────────────│
│   数据源            │ PMU、软件计数器、内核事件                 │
│                                                                 │
│   选择建议：                                                    │
│   ├── 快速分析 → perf + 火焰图                                  │
│   ├── 一次性跟踪 → bpftrace                                     │
│   ├── 复杂分析 → BCC                                            │
│   └── 生产环境 → libbpf + CO-RE                                 │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

---

*持续更新中...*
