# è¾“å‡ºæ§åˆ¶è¯¦è§£

è¾“å‡ºæ§åˆ¶è®©ä½ èƒ½å¤Ÿç²¾ç¡®æ§åˆ¶ Agent å¦‚ä½•è¿”å›ç»“æœâ€”â€”åŒ…æ‹¬è¾“å‡ºçš„æ–¹å¼ï¼ˆæµå¼ vs ä¸€æ¬¡æ€§ï¼‰å’Œè¾“å‡ºçš„æ ¼å¼ï¼ˆè‡ªç”±æ–‡æœ¬ vs ç»“æ„åŒ–æ•°æ®ï¼‰ã€‚

## ç›®å½•

- [æµå¼è¾“å‡º](#æµå¼è¾“å‡º)
  - [Agent è¿›åº¦æµå¼è¾“å‡º](#agent-è¿›åº¦æµå¼è¾“å‡º)
  - [LLM Token æµå¼è¾“å‡º](#llm-token-æµå¼è¾“å‡º)
  - [è‡ªå®šä¹‰æ›´æ–°æµå¼è¾“å‡º](#è‡ªå®šä¹‰æ›´æ–°æµå¼è¾“å‡º)
  - [å¤šæ¨¡å¼æµå¼è¾“å‡º](#å¤šæ¨¡å¼æµå¼è¾“å‡º)
- [ç»“æ„åŒ–è¾“å‡º](#ç»“æ„åŒ–è¾“å‡º)
  - [Provider ç­–ç•¥](#provider-ç­–ç•¥)
  - [Tool ç­–ç•¥](#tool-ç­–ç•¥)
  - [é”™è¯¯å¤„ç†](#é”™è¯¯å¤„ç†)
- [ç»„åˆä½¿ç”¨](#ç»„åˆä½¿ç”¨)

---

## æµå¼è¾“å‡º

æµå¼è¾“å‡ºï¼ˆStreamingï¼‰å¯¹äºæå‡åŸºäº LLM æ„å»ºçš„åº”ç”¨çš„å“åº”æ€§è‡³å…³é‡è¦ã€‚é€šè¿‡åœ¨å®Œæ•´å“åº”å‡†å¤‡å¥½ä¹‹å‰é€æ­¥æ˜¾ç¤ºè¾“å‡ºï¼Œæµå¼è¾“å‡ºæ˜¾è‘—æ”¹å–„äº†ç”¨æˆ·ä½“éªŒï¼Œç‰¹åˆ«æ˜¯åœ¨å¤„ç† LLM å»¶è¿Ÿæ—¶ã€‚

### æµå¼è¾“å‡ºèƒ½åšä»€ä¹ˆ

| åŠŸèƒ½ | è¯´æ˜ |
|------|------|
| æµå¼ Agent è¿›åº¦ | æ¯ä¸ª Agent æ­¥éª¤åè·å–çŠ¶æ€æ›´æ–° |
| æµå¼ LLM Token | é€ token æµå¼è¾“å‡ºæ¨¡å‹ç”Ÿæˆçš„å†…å®¹ |
| æµå¼è‡ªå®šä¹‰æ›´æ–° | å‘é€ç”¨æˆ·å®šä¹‰çš„ä¿¡å·ï¼ˆå¦‚ "å·²è·å– 10/100 æ¡è®°å½•"ï¼‰ |
| å¤šæ¨¡å¼æµå¼è¾“å‡º | åŒæ—¶ä½¿ç”¨å¤šç§æµå¼æ¨¡å¼ |

### æ”¯æŒçš„æµå¼æ¨¡å¼

å°†ä»¥ä¸‹æ¨¡å¼ä½œä¸ºåˆ—è¡¨ä¼ é€’ç»™ `stream` æˆ– `astream` æ–¹æ³•ï¼š

| æ¨¡å¼ | è¯´æ˜ |
|------|------|
| `updates` | æ¯ä¸ª Agent æ­¥éª¤åæµå¼è¾“å‡ºçŠ¶æ€æ›´æ–°ã€‚å¦‚æœåŒä¸€æ­¥éª¤ä¸­æœ‰å¤šä¸ªæ›´æ–°ï¼Œå®ƒä»¬ä¼šåˆ†åˆ«æµå¼è¾“å‡º |
| `messages` | ä»ä»»ä½•è°ƒç”¨ LLM çš„å›¾èŠ‚ç‚¹æµå¼è¾“å‡º `(token, metadata)` å…ƒç»„ |
| `custom` | ä½¿ç”¨ stream writer ä»å›¾èŠ‚ç‚¹å†…éƒ¨æµå¼è¾“å‡ºè‡ªå®šä¹‰æ•°æ® |


### Agent è¿›åº¦æµå¼è¾“å‡º

ä½¿ç”¨ `stream_mode="updates"` æµå¼è¾“å‡º Agent è¿›åº¦ã€‚è¿™ä¼šåœ¨æ¯ä¸ª Agent æ­¥éª¤åå‘å‡ºä¸€ä¸ªäº‹ä»¶ã€‚

ä¾‹å¦‚ï¼Œå¦‚æœ Agent è°ƒç”¨ä¸€æ¬¡å·¥å…·ï¼Œä½ ä¼šçœ‹åˆ°ä»¥ä¸‹æ›´æ–°ï¼š

1. **LLM èŠ‚ç‚¹**ï¼šå¸¦æœ‰å·¥å…·è°ƒç”¨è¯·æ±‚çš„ `AIMessage`
2. **Tool èŠ‚ç‚¹**ï¼šå¸¦æœ‰æ‰§è¡Œç»“æœçš„ `ToolMessage`
3. **LLM èŠ‚ç‚¹**ï¼šæœ€ç»ˆ AI å“åº”

```python
from langchain.agents import create_agent

def get_weather(city: str) -> str:
    """Get weather for a given city."""
    return f"It's always sunny in {city}!"

agent = create_agent(
    model="gpt-4o",
    tools=[get_weather],
)

for chunk in agent.stream(
    {"messages": [{"role": "user", "content": "æ—§é‡‘å±±çš„å¤©æ°”æ€ä¹ˆæ ·ï¼Ÿ"}]},
    stream_mode="updates",
):
    for step, data in chunk.items():
        print(f"æ­¥éª¤: {step}")
        print(f"å†…å®¹: {data['messages'][-1].content_blocks}")
```

è¾“å‡ºï¼š
```
æ­¥éª¤: model
å†…å®¹: [{'type': 'tool_call', 'name': 'get_weather', 'args': {'city': 'San Francisco'}, 'id': 'call_xxx'}]
æ­¥éª¤: tools
å†…å®¹: [{'type': 'text', 'text': "It's always sunny in San Francisco!"}]
æ­¥éª¤: model
å†…å®¹: [{'type': 'text', 'text': 'æ—§é‡‘å±±çš„å¤©æ°”æ€»æ˜¯é˜³å…‰æ˜åªšï¼'}]
```

### LLM Token æµå¼è¾“å‡º

ä½¿ç”¨ `stream_mode="messages"` é€ token æµå¼è¾“å‡º LLM ç”Ÿæˆçš„å†…å®¹ï¼š

```python
from langchain.agents import create_agent

def get_weather(city: str) -> str:
    """Get weather for a given city."""
    return f"It's always sunny in {city}!"

agent = create_agent(
    model="gpt-4o",
    tools=[get_weather],
)

for token, metadata in agent.stream(
    {"messages": [{"role": "user", "content": "æ—§é‡‘å±±çš„å¤©æ°”æ€ä¹ˆæ ·ï¼Ÿ"}]},
    stream_mode="messages",
):
    print(f"èŠ‚ç‚¹: {metadata['langgraph_node']}")
    print(f"å†…å®¹: {token.content_blocks}")
```

è¾“å‡ºï¼ˆéƒ¨åˆ†ï¼‰ï¼š
```
èŠ‚ç‚¹: model
å†…å®¹: [{'type': 'tool_call_chunk', 'id': 'call_xxx', 'name': 'get_weather', 'args': '', 'index': 0}]
èŠ‚ç‚¹: model
å†…å®¹: [{'type': 'tool_call_chunk', 'id': None, 'name': None, 'args': '{"', 'index': 0}]
èŠ‚ç‚¹: model
å†…å®¹: [{'type': 'tool_call_chunk', 'id': None, 'name': None, 'args': 'city', 'index': 0}]
...
èŠ‚ç‚¹: tools
å†…å®¹: [{'type': 'text', 'text': "It's always sunny in San Francisco!"}]
èŠ‚ç‚¹: model
å†…å®¹: [{'type': 'text', 'text': 'æ—§é‡‘å±±'}]
èŠ‚ç‚¹: model
å†…å®¹: [{'type': 'text', 'text': 'çš„å¤©æ°”'}]
èŠ‚ç‚¹: model
å†…å®¹: [{'type': 'text', 'text': 'æ€»æ˜¯'}]
èŠ‚ç‚¹: model
å†…å®¹: [{'type': 'text', 'text': 'é˜³å…‰æ˜åªš'}]
èŠ‚ç‚¹: model
å†…å®¹: [{'type': 'text', 'text': 'ï¼'}]
```

### è‡ªå®šä¹‰æ›´æ–°æµå¼è¾“å‡º

ä½¿ç”¨ `get_stream_writer` åœ¨å·¥å…·æ‰§è¡Œæ—¶æµå¼è¾“å‡ºè‡ªå®šä¹‰æ›´æ–°ï¼š

```python
from langchain.agents import create_agent
from langgraph.config import get_stream_writer

def get_weather(city: str) -> str:
    """Get weather for a given city."""
    writer = get_stream_writer()  # è·å– stream writer
    
    # æµå¼è¾“å‡ºä»»æ„æ•°æ®
    writer(f"æ­£åœ¨æŸ¥æ‰¾åŸå¸‚æ•°æ®: {city}")
    writer(f"å·²è·å– {city} çš„æ•°æ®")
    
    return f"It's always sunny in {city}!"

agent = create_agent(
    model="gpt-4o",
    tools=[get_weather],
)

for chunk in agent.stream(
    {"messages": [{"role": "user", "content": "æ—§é‡‘å±±çš„å¤©æ°”æ€ä¹ˆæ ·ï¼Ÿ"}]},
    stream_mode="custom"  # ä½¿ç”¨ custom æ¨¡å¼
):
    print(chunk)
```

è¾“å‡ºï¼š
```
æ­£åœ¨æŸ¥æ‰¾åŸå¸‚æ•°æ®: San Francisco
å·²è·å– San Francisco çš„æ•°æ®
```

> âš ï¸ å¦‚æœåœ¨å·¥å…·ä¸­ä½¿ç”¨ `get_stream_writer`ï¼Œè¯¥å·¥å…·åªèƒ½åœ¨ LangGraph æ‰§è¡Œä¸Šä¸‹æ–‡ä¸­è°ƒç”¨ã€‚

### å¤šæ¨¡å¼æµå¼è¾“å‡º

å¯ä»¥åŒæ—¶æŒ‡å®šå¤šç§æµå¼æ¨¡å¼ï¼š`stream_mode=["updates", "custom"]`

è¾“å‡ºå°†æ˜¯ `(mode, chunk)` å…ƒç»„ï¼Œå…¶ä¸­ `mode` æ˜¯æµå¼æ¨¡å¼åç§°ï¼Œ`chunk` æ˜¯è¯¥æ¨¡å¼æµå¼è¾“å‡ºçš„æ•°æ®ï¼š

```python
from langchain.agents import create_agent
from langgraph.config import get_stream_writer

def get_weather(city: str) -> str:
    """Get weather for a given city."""
    writer = get_stream_writer()
    writer(f"æ­£åœ¨æŸ¥æ‰¾åŸå¸‚æ•°æ®: {city}")
    writer(f"å·²è·å– {city} çš„æ•°æ®")
    return f"It's always sunny in {city}!"

agent = create_agent(
    model="gpt-4o",
    tools=[get_weather],
)

for stream_mode, chunk in agent.stream(
    {"messages": [{"role": "user", "content": "æ—§é‡‘å±±çš„å¤©æ°”æ€ä¹ˆæ ·ï¼Ÿ"}]},
    stream_mode=["updates", "custom"]  # å¤šç§æ¨¡å¼
):
    print(f"æ¨¡å¼: {stream_mode}")
    print(f"å†…å®¹: {chunk}")
    print()
```

è¾“å‡ºï¼š
```
æ¨¡å¼: updates
å†…å®¹: {'model': {'messages': [AIMessage(content='', tool_calls=[...])]}}

æ¨¡å¼: custom
å†…å®¹: æ­£åœ¨æŸ¥æ‰¾åŸå¸‚æ•°æ®: San Francisco

æ¨¡å¼: custom
å†…å®¹: å·²è·å– San Francisco çš„æ•°æ®

æ¨¡å¼: updates
å†…å®¹: {'tools': {'messages': [ToolMessage(content="It's always sunny in San Francisco!")]}}

æ¨¡å¼: updates
å†…å®¹: {'model': {'messages': [AIMessage(content='æ—§é‡‘å±±çš„å¤©æ°”æ€»æ˜¯é˜³å…‰æ˜åªšï¼')]}}
```


### å¸¸è§æµå¼è¾“å‡ºæ¨¡å¼

#### æµå¼å·¥å…·è°ƒç”¨

ä½ å¯èƒ½æƒ³åŒæ—¶æµå¼è¾“å‡ºï¼š
1. å·¥å…·è°ƒç”¨ç”Ÿæˆæ—¶çš„éƒ¨åˆ† JSON
2. æ‰§è¡Œçš„å®Œæ•´ã€å·²è§£æçš„å·¥å…·è°ƒç”¨

```python
from typing import Any
from langchain.agents import create_agent
from langchain.messages import AIMessage, AIMessageChunk, AnyMessage, ToolMessage

def get_weather(city: str) -> str:
    """Get weather for a given city."""
    return f"It's always sunny in {city}!"

agent = create_agent("gpt-4o", tools=[get_weather])

def _render_message_chunk(token: AIMessageChunk) -> None:
    if token.text:
        print(token.text, end="|")
    if token.tool_call_chunks:
        print(token.tool_call_chunks)

def _render_completed_message(message: AnyMessage) -> None:
    if isinstance(message, AIMessage) and message.tool_calls:
        print(f"å·¥å…·è°ƒç”¨: {message.tool_calls}")
    if isinstance(message, ToolMessage):
        print(f"å·¥å…·å“åº”: {message.content_blocks}")

input_message = {"role": "user", "content": "æ³¢å£«é¡¿çš„å¤©æ°”æ€ä¹ˆæ ·ï¼Ÿ"}

for stream_mode, data in agent.stream(
    {"messages": [input_message]},
    stream_mode=["messages", "updates"],  # åŒæ—¶ä½¿ç”¨ä¸¤ç§æ¨¡å¼
):
    if stream_mode == "messages":
        token, metadata = data
        if isinstance(token, AIMessageChunk):
            _render_message_chunk(token)  # æµå¼è¾“å‡º token
    
    if stream_mode == "updates":
        for source, update in data.items():
            if source in ("model", "tools"):
                _render_completed_message(update["messages"][-1])  # å®Œæ•´æ¶ˆæ¯
```

è¾“å‡ºï¼š
```
[{'name': 'get_weather', 'args': '', 'id': 'call_xxx', 'index': 0, 'type': 'tool_call_chunk'}]
[{'name': None, 'args': '{"', 'id': None, 'index': 0, 'type': 'tool_call_chunk'}]
[{'name': None, 'args': 'city', 'id': None, 'index': 0, 'type': 'tool_call_chunk'}]
[{'name': None, 'args': '":"', 'id': None, 'index': 0, 'type': 'tool_call_chunk'}]
[{'name': None, 'args': 'Boston', 'id': None, 'index': 0, 'type': 'tool_call_chunk'}]
[{'name': None, 'args': '"}', 'id': None, 'index': 0, 'type': 'tool_call_chunk'}]
å·¥å…·è°ƒç”¨: [{'name': 'get_weather', 'args': {'city': 'Boston'}, 'id': 'call_xxx', 'type': 'tool_call'}]
å·¥å…·å“åº”: [{'type': 'text', 'text': "It's always sunny in Boston!"}]
The| weather| in| Boston| is| **|sun|ny|**|.|
```

#### ç´¯ç§¯ chunks æ„å»ºå®Œæ•´æ¶ˆæ¯

å¦‚æœéœ€è¦åœ¨æµå¼å¾ªç¯ä¸­èšåˆæ¶ˆæ¯ chunksï¼š

```python
input_message = {"role": "user", "content": "æ³¢å£«é¡¿çš„å¤©æ°”æ€ä¹ˆæ ·ï¼Ÿ"}

full_message = None

for stream_mode, data in agent.stream(
    {"messages": [input_message]},
    stream_mode=["messages", "updates"],
):
    if stream_mode == "messages":
        token, metadata = data
        if isinstance(token, AIMessageChunk):
            _render_message_chunk(token)
            # ç´¯ç§¯ chunks
            full_message = token if full_message is None else full_message + token
            
            if token.chunk_position == "last":  # æœ€åä¸€ä¸ª chunk
                if full_message.tool_calls:
                    print(f"å·¥å…·è°ƒç”¨: {full_message.tool_calls}")
                full_message = None  # é‡ç½®
    
    if stream_mode == "updates":
        for source, update in data.items():
            if source == "tools":
                _render_completed_message(update["messages"][-1])
```

#### ä»å­ Agent æµå¼è¾“å‡º

å½“æœ‰å¤šä¸ª LLM æ—¶ï¼Œé€šå¸¸éœ€è¦åŒºåˆ†æ¶ˆæ¯çš„æ¥æºã€‚

##### å­ Agent çš„è°ƒç”¨æ–¹å¼

åœ¨ LangChain ä¸­ï¼Œ**å­ Agent é€šå¸¸è¢«åŒ…è£…æˆå·¥å…·**ä¾›ä¸» Agent è°ƒç”¨ï¼š

```python
# åˆ›å»ºå­ Agent
weather_agent = create_agent(model=weather_model, tools=[get_weather])

# æŠŠå­ Agent åŒ…è£…æˆå·¥å…·
def call_weather_agent(query: str) -> str:
    """Query the weather agent."""
    result = weather_agent.invoke({"messages": [{"role": "user", "content": query}]})
    return result["messages"][-1].text

# ä¸» Agent æŠŠå­ Agent å½“ä½œå·¥å…·ä½¿ç”¨
agent = create_agent(model=supervisor_model, tools=[call_weather_agent])
```

**ä¸ºä»€ä¹ˆè¿™æ ·è®¾è®¡ï¼Ÿ**

- å­ Agent å¯¹ä¸» Agent æ¥è¯´å°±æ˜¯ä¸€ä¸ª"èƒ½åŠ›"ï¼Œå’Œæ™®é€šå·¥å…·æ²¡åŒºåˆ«
- ä¸» Agent å†³å®šä½•æ—¶è°ƒç”¨ã€ä¼ ä»€ä¹ˆå‚æ•°
- ç¬¦åˆ ReAct æ¨¡å¼ï¼šä¸» Agent æ˜¯"å¤§è„‘"ï¼Œå­ Agent æ˜¯"ä¸“ä¸šå·¥å…·"

**æ‰§è¡Œæµç¨‹ï¼š**

```
ç”¨æˆ·: "æ³¢å£«é¡¿çš„å¤©æ°”æ€ä¹ˆæ ·ï¼Ÿ"
        â†“
ä¸» Agent (supervisor) æ€è€ƒ:
  "è¿™æ˜¯å¤©æ°”é—®é¢˜ï¼Œæˆ‘æœ‰ä¸ª call_weather_agent å·¥å…·"
        â†“
è°ƒç”¨å·¥å…·: call_weather_agent("æ³¢å£«é¡¿å¤©æ°”")
        â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ å­ Agent (weather_sub_agent) æ‰§è¡Œ   â”‚
â”‚   â†“                                 â”‚
â”‚ è°ƒç”¨ get_weather("Boston")          â”‚
â”‚   â†“                                 â”‚
â”‚ è¿”å›: "It's always sunny in Boston!"â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
        â†“
ä¸» Agent æ”¶åˆ°ç»“æœï¼Œç»„ç»‡æœ€ç»ˆå›ç­”
```

##### åŒºåˆ†å¤šä¸ª LLM çš„æ¥æº

å¯ä»¥ä½¿ç”¨ `tags` åˆå§‹åŒ–æ¨¡å‹ï¼Œè¿™äº›æ ‡ç­¾åœ¨ `"messages"` æ¨¡å¼æµå¼è¾“å‡ºæ—¶å¯ä»¥åœ¨ metadata ä¸­è®¿é—®ï¼š

```python
from langchain.agents import create_agent
from langchain.chat_models import init_chat_model
from langchain.messages import AIMessage, AIMessageChunk

def get_weather(city: str) -> str:
    """Get weather for a given city."""
    return f"It's always sunny in {city}!"

# å­ Agent çš„æ¨¡å‹ï¼Œå¸¦æ ‡ç­¾
weather_model = init_chat_model(
    "gpt-4o",
    tags=["weather_sub_agent"],  # æ ‡ç­¾
)
weather_agent = create_agent(model=weather_model, tools=[get_weather])

def call_weather_agent(query: str) -> str:
    """Query the weather agent."""
    result = weather_agent.invoke({"messages": [{"role": "user", "content": query}]})
    return result["messages"][-1].text

# ä¸» Agent çš„æ¨¡å‹ï¼Œå¸¦æ ‡ç­¾
supervisor_model = init_chat_model(
    "gpt-4o",
    tags=["supervisor"],  # æ ‡ç­¾
)
agent = create_agent(model=supervisor_model, tools=[call_weather_agent])

# æµå¼è¾“å‡ºæ—¶åŒºåˆ†æ¥æº
input_message = {"role": "user", "content": "æ³¢å£«é¡¿çš„å¤©æ°”æ€ä¹ˆæ ·ï¼Ÿ"}
current_agent = None

for _, stream_mode, data in agent.stream(
    {"messages": [input_message]},
    stream_mode=["messages", "updates"],
    subgraphs=True,  # å¯ç”¨å­å›¾æµå¼è¾“å‡º
):
    if stream_mode == "messages":
        token, metadata = data
        if tags := metadata.get("tags", []):
            this_agent = tags[0]
            if this_agent != current_agent:
                print(f"ğŸ¤– {this_agent}: ")
                current_agent = this_agent
        
        if isinstance(token, AIMessage):
            _render_message_chunk(token)
    
    if stream_mode == "updates":
        for source, update in data.items():
            if source in ("model", "tools"):
                _render_completed_message(update["messages"][-1])
```

è¾“å‡ºï¼š
```
ğŸ¤– supervisor: 
[{'name': 'call_weather_agent', 'args': '', 'id': 'call_xxx', ...}]
...
å·¥å…·è°ƒç”¨: [{'name': 'call_weather_agent', 'args': {'query': 'Boston weather'}, ...}]
ğŸ¤– weather_sub_agent: 
[{'name': 'get_weather', 'args': '', 'id': 'call_yyy', ...}]
...
å·¥å…·è°ƒç”¨: [{'name': 'get_weather', 'args': {'city': 'Boston'}, ...}]
å·¥å…·å“åº”: [{'type': 'text', 'text': "It's always sunny in Boston!"}]
Boston| weather|:| **|Sunny|**|
ğŸ¤– supervisor: 
Boston| weather|:| **|Sunny|**|
```

### ç¦ç”¨æµå¼è¾“å‡º

åœ¨æŸäº›åº”ç”¨ä¸­ï¼Œä½ å¯èƒ½éœ€è¦ç¦ç”¨ç‰¹å®šæ¨¡å‹çš„ token æµå¼è¾“å‡ºã€‚è¿™åœ¨ä»¥ä¸‹æƒ…å†µä¸‹å¾ˆæœ‰ç”¨ï¼š

- åœ¨å¤š Agent ç³»ç»Ÿä¸­æ§åˆ¶å“ªäº› Agent æµå¼è¾“å‡º
- æ··åˆä½¿ç”¨æ”¯æŒå’Œä¸æ”¯æŒæµå¼è¾“å‡ºçš„æ¨¡å‹
- éƒ¨ç½²åˆ° LangSmith æ—¶æƒ³é˜»æ­¢æŸäº›æ¨¡å‹è¾“å‡ºè¢«æµå¼ä¼ è¾“åˆ°å®¢æˆ·ç«¯

åˆå§‹åŒ–æ¨¡å‹æ—¶è®¾ç½® `streaming=False`ï¼š

```python
from langchain_openai import ChatOpenAI

model = ChatOpenAI(
    model="gpt-4o",
    streaming=False  # ç¦ç”¨æµå¼è¾“å‡º
)
```

> âš ï¸ å¹¶éæ‰€æœ‰èŠå¤©æ¨¡å‹é›†æˆéƒ½æ”¯æŒ `streaming` å‚æ•°ã€‚å¦‚æœä½ çš„æ¨¡å‹ä¸æ”¯æŒï¼Œå¯ä»¥ä½¿ç”¨ `disable_streaming=True`ï¼Œè¿™ä¸ªå‚æ•°åœ¨æ‰€æœ‰èŠå¤©æ¨¡å‹çš„åŸºç±»ä¸­éƒ½å¯ç”¨ã€‚

### ä¸‰ç§æµå¼æ¨¡å¼å¯¹æ¯”

| æ¨¡å¼ | ç”¨é€” | è¾“å‡ºå†…å®¹ |
|------|------|----------|
| `updates` | è·Ÿè¸ª Agent æ‰§è¡Œè¿›åº¦ | æ¯ä¸ªæ­¥éª¤çš„å®Œæ•´çŠ¶æ€æ›´æ–° |
| `messages` | å®æ—¶æ˜¾ç¤º LLM ç”Ÿæˆå†…å®¹ | é€ token è¾“å‡º + metadata |
| `custom` | è‡ªå®šä¹‰è¿›åº¦åé¦ˆ | ä»»æ„ç”¨æˆ·å®šä¹‰çš„æ•°æ® |

---


## ç»“æ„åŒ–è¾“å‡º

ç»“æ„åŒ–è¾“å‡ºï¼ˆStructured Outputï¼‰è®© Agent ä»¥ç‰¹å®šã€å¯é¢„æµ‹çš„æ ¼å¼è¿”å›æ•°æ®ã€‚ä¸å†éœ€è¦è§£æè‡ªç„¶è¯­è¨€å“åº”ï¼Œè€Œæ˜¯ç›´æ¥è·å– JSON å¯¹è±¡ã€Pydantic æ¨¡å‹æˆ– dataclass å½¢å¼çš„ç»“æ„åŒ–æ•°æ®ã€‚

### ä¸ºä»€ä¹ˆéœ€è¦ç»“æ„åŒ–è¾“å‡ºï¼Ÿ

```python
# æ²¡æœ‰ç»“æ„åŒ–è¾“å‡º
response = "ç”¨æˆ·åæ˜¯å¼ ä¸‰ï¼Œé‚®ç®±æ˜¯ zhangsan@example.comï¼Œç”µè¯æ˜¯ 13800138000"
# éœ€è¦è‡ªå·±è§£æå­—ç¬¦ä¸²ï¼Œå®¹æ˜“å‡ºé”™

# æœ‰ç»“æ„åŒ–è¾“å‡º
response = ContactInfo(name="å¼ ä¸‰", email="zhangsan@example.com", phone="13800138000")
# ç›´æ¥ä½¿ç”¨å¯¹è±¡å±æ€§ï¼Œç±»å‹å®‰å…¨
```

### åŸºæœ¬ç”¨æ³•

ä½¿ç”¨ `response_format` å‚æ•°æŒ‡å®šè¾“å‡ºæ ¼å¼ï¼š

```python
from pydantic import BaseModel, Field
from langchain.agents import create_agent

class ContactInfo(BaseModel):
    """è”ç³»äººä¿¡æ¯"""
    name: str = Field(description="å§“å")
    email: str = Field(description="é‚®ç®±åœ°å€")
    phone: str = Field(description="ç”µè¯å·ç ")

agent = create_agent(
    model="gpt-4o",
    response_format=ContactInfo  # æŒ‡å®šè¾“å‡ºæ ¼å¼
)

result = agent.invoke({
    "messages": [{
        "role": "user", 
        "content": "æå–è”ç³»ä¿¡æ¯: å¼ ä¸‰, zhangsan@example.com, 13800138000"
    }]
})

print(result["structured_response"])
# ContactInfo(name='å¼ ä¸‰', email='zhangsan@example.com', phone='13800138000')
```

ç»“æ„åŒ–å“åº”å­˜å‚¨åœ¨ `structured_response` é”®ä¸­ã€‚

### ä¸¤ç§ç­–ç•¥

| ç­–ç•¥ | è¯´æ˜ | é€‚ç”¨åœºæ™¯ |
|------|------|----------|
| `ProviderStrategy` | ä½¿ç”¨æ¨¡å‹æä¾›å•†çš„åŸç”Ÿç»“æ„åŒ–è¾“å‡º | OpenAIã€Anthropicã€xAI ç­‰æ”¯æŒçš„æ¨¡å‹ |
| `ToolStrategy` | ä½¿ç”¨å·¥å…·è°ƒç”¨å®ç°ç»“æ„åŒ–è¾“å‡º | æ‰€æœ‰æ”¯æŒå·¥å…·è°ƒç”¨çš„æ¨¡å‹ |

å½“ç›´æ¥ä¼ é€’ schema ç±»å‹æ—¶ï¼ŒLangChain ä¼šè‡ªåŠ¨é€‰æ‹©ï¼š
- å¦‚æœæ¨¡å‹æ”¯æŒåŸç”Ÿç»“æ„åŒ–è¾“å‡º â†’ `ProviderStrategy`
- å¦åˆ™ â†’ `ToolStrategy`


### Provider ç­–ç•¥

æŸäº›æ¨¡å‹æä¾›å•†ï¼ˆå¦‚ OpenAIã€Anthropicã€Geminiï¼‰åŸç”Ÿæ”¯æŒç»“æ„åŒ–è¾“å‡ºï¼Œè¿™æ˜¯æœ€å¯é çš„æ–¹æ³•ã€‚

```python
from langchain.agents.structured_output import ProviderStrategy

class ProviderStrategy:
    schema: type        # è¾“å‡ºæ ¼å¼çš„ schema
    strict: bool = None # æ˜¯å¦å¯ç”¨ä¸¥æ ¼æ¨¡å¼ï¼ˆéƒ¨åˆ†æä¾›å•†æ”¯æŒï¼‰
```

#### æ”¯æŒçš„ Schema ç±»å‹

##### Pydantic æ¨¡å‹ï¼ˆæ¨èï¼‰

```python
from pydantic import BaseModel, Field
from langchain.agents import create_agent

class ContactInfo(BaseModel):
    """è”ç³»äººä¿¡æ¯"""
    name: str = Field(description="å§“å")
    email: str = Field(description="é‚®ç®±åœ°å€")
    phone: str = Field(description="ç”µè¯å·ç ")

agent = create_agent(
    model="gpt-4o",
    response_format=ContactInfo  # è‡ªåŠ¨é€‰æ‹© ProviderStrategy
)

result = agent.invoke({
    "messages": [{"role": "user", "content": "æå–: å¼ ä¸‰, zhangsan@example.com, 13800138000"}]
})

print(result["structured_response"])
# ContactInfo(name='å¼ ä¸‰', email='zhangsan@example.com', phone='13800138000')
print(result["structured_response"].name)  # å¼ ä¸‰ - å¯ä»¥ç›´æ¥è®¿é—®å±æ€§
```

è¿”å› Pydantic å®ä¾‹ï¼Œæœ‰ç±»å‹æç¤ºå’Œè‡ªåŠ¨éªŒè¯ã€‚

##### Dataclass

```python
from dataclasses import dataclass
from langchain.agents import create_agent

@dataclass
class ContactInfo:
    """è”ç³»äººä¿¡æ¯"""
    name: str   # å§“å
    email: str  # é‚®ç®±åœ°å€
    phone: str  # ç”µè¯å·ç 

agent = create_agent(
    model="gpt-4o",
    response_format=ContactInfo
)

result = agent.invoke({
    "messages": [{"role": "user", "content": "æå–: å¼ ä¸‰, zhangsan@example.com, 13800138000"}]
})

result["structured_response"]
# {'name': 'å¼ ä¸‰', 'email': 'zhangsan@example.com', 'phone': '13800138000'}
```

è¿”å›å­—å…¸ã€‚

##### TypedDict

```python
from typing_extensions import TypedDict
from langchain.agents import create_agent

class ContactInfo(TypedDict):
    """è”ç³»äººä¿¡æ¯"""
    name: str   # å§“å
    email: str  # é‚®ç®±åœ°å€
    phone: str  # ç”µè¯å·ç 

agent = create_agent(
    model="gpt-4o",
    response_format=ContactInfo
)

result = agent.invoke({
    "messages": [{"role": "user", "content": "æå–: å¼ ä¸‰, zhangsan@example.com, 13800138000"}]
})

result["structured_response"]
# {'name': 'å¼ ä¸‰', 'email': 'zhangsan@example.com', 'phone': '13800138000'}
```

è¿”å›å­—å…¸ã€‚

##### JSON Schema

```python
from langchain.agents import create_agent
from langchain.agents.structured_output import ProviderStrategy

contact_info_schema = {
    "type": "object",
    "description": "è”ç³»äººä¿¡æ¯",
    "properties": {
        "name": {"type": "string", "description": "å§“å"},
        "email": {"type": "string", "description": "é‚®ç®±åœ°å€"},
        "phone": {"type": "string", "description": "ç”µè¯å·ç "}
    },
    "required": ["name", "email", "phone"]
}

agent = create_agent(
    model="gpt-4o",
    response_format=ProviderStrategy(contact_info_schema)
)

result = agent.invoke({
    "messages": [{"role": "user", "content": "æå–: å¼ ä¸‰, zhangsan@example.com, 13800138000"}]
})

result["structured_response"]
# {'name': 'å¼ ä¸‰', 'email': 'zhangsan@example.com', 'phone': '13800138000'}
```

è¿”å›å­—å…¸ã€‚


### Tool ç­–ç•¥

å¯¹äºä¸æ”¯æŒåŸç”Ÿç»“æ„åŒ–è¾“å‡ºçš„æ¨¡å‹ï¼ŒLangChain ä½¿ç”¨å·¥å…·è°ƒç”¨æ¥å®ç°ã€‚è¿™é€‚ç”¨äºæ‰€æœ‰æ”¯æŒå·¥å…·è°ƒç”¨çš„æ¨¡å‹ã€‚

```python
from langchain.agents.structured_output import ToolStrategy

class ToolStrategy:
    schema: type                    # è¾“å‡ºæ ¼å¼çš„ schema
    tool_message_content: str = None  # è‡ªå®šä¹‰å·¥å…·æ¶ˆæ¯å†…å®¹
    handle_errors: bool | str | ... = True  # é”™è¯¯å¤„ç†ç­–ç•¥
```

#### åŸºæœ¬ç”¨æ³•

```python
from pydantic import BaseModel, Field
from typing import Literal
from langchain.agents import create_agent
from langchain.agents.structured_output import ToolStrategy

class ProductReview(BaseModel):
    """äº§å“è¯„ä»·åˆ†æ"""
    rating: int | None = Field(description="è¯„åˆ† 1-5", ge=1, le=5)
    sentiment: Literal["positive", "negative"] = Field(description="æƒ…æ„Ÿå€¾å‘")
    key_points: list[str] = Field(description="å…³é”®ç‚¹ï¼Œå°å†™ï¼Œ1-3 ä¸ªè¯")

agent = create_agent(
    model="gpt-4o",
    tools=[],
    response_format=ToolStrategy(ProductReview)
)

result = agent.invoke({
    "messages": [{
        "role": "user", 
        "content": "åˆ†æè¿™æ¡è¯„ä»·: 'å¾ˆæ£’çš„äº§å“ï¼Œ5 æ˜Ÿå¥½è¯„ã€‚å‘è´§å¿«ï¼Œä½†æœ‰ç‚¹è´µ'"
    }]
})

result["structured_response"]
# ProductReview(rating=5, sentiment='positive', key_points=['å‘è´§å¿«', 'æœ‰ç‚¹è´µ'])
```

#### Union ç±»å‹ï¼ˆå¤šç§è¾“å‡ºæ ¼å¼ï¼‰

æ¨¡å‹ä¼šæ ¹æ®ä¸Šä¸‹æ–‡é€‰æ‹©æœ€åˆé€‚çš„ schemaï¼š

```python
from pydantic import BaseModel, Field
from typing import Literal, Union
from langchain.agents import create_agent
from langchain.agents.structured_output import ToolStrategy

class ProductReview(BaseModel):
    """äº§å“è¯„ä»·"""
    rating: int | None = Field(description="è¯„åˆ† 1-5", ge=1, le=5)
    sentiment: Literal["positive", "negative"] = Field(description="æƒ…æ„Ÿå€¾å‘")
    key_points: list[str] = Field(description="å…³é”®ç‚¹")

class CustomerComplaint(BaseModel):
    """å®¢æˆ·æŠ•è¯‰"""
    issue_type: Literal["product", "service", "shipping", "billing"] = Field(description="é—®é¢˜ç±»å‹")
    severity: Literal["low", "medium", "high"] = Field(description="ä¸¥é‡ç¨‹åº¦")
    description: str = Field(description="é—®é¢˜æè¿°")

agent = create_agent(
    model="gpt-4o",
    tools=[],
    response_format=ToolStrategy(Union[ProductReview, CustomerComplaint])
)

# è¾“å…¥è¯„ä»· â†’ è¿”å› ProductReview
result = agent.invoke({
    "messages": [{"role": "user", "content": "åˆ†æ: 'å¾ˆæ£’çš„äº§å“ï¼Œ5 æ˜Ÿå¥½è¯„'"}]
})
# ProductReview(rating=5, sentiment='positive', key_points=['å¾ˆæ£’'])

# è¾“å…¥æŠ•è¯‰ â†’ è¿”å› CustomerComplaint
result = agent.invoke({
    "messages": [{"role": "user", "content": "åˆ†æ: 'å‘è´§å¤ªæ…¢äº†ï¼Œç­‰äº†ä¸¤å‘¨è¿˜æ²¡åˆ°'"}]
})
# CustomerComplaint(issue_type='shipping', severity='high', description='å‘è´§å»¶è¿Ÿä¸¤å‘¨')
```

#### è‡ªå®šä¹‰å·¥å…·æ¶ˆæ¯å†…å®¹

```python
from pydantic import BaseModel, Field
from typing import Literal
from langchain.agents import create_agent
from langchain.agents.structured_output import ToolStrategy

class MeetingAction(BaseModel):
    """ä¼šè®®å¾…åŠäº‹é¡¹"""
    task: str = Field(description="å…·ä½“ä»»åŠ¡")
    assignee: str = Field(description="è´Ÿè´£äºº")
    priority: Literal["low", "medium", "high"] = Field(description="ä¼˜å…ˆçº§")

agent = create_agent(
    model="gpt-4o",
    tools=[],
    response_format=ToolStrategy(
        schema=MeetingAction,
        tool_message_content="å¾…åŠäº‹é¡¹å·²è®°å½•åˆ°ä¼šè®®çºªè¦ï¼"  # è‡ªå®šä¹‰æ¶ˆæ¯
    )
)

agent.invoke({
    "messages": [{"role": "user", "content": "ä¼šè®®è®°å½•: å°ç‹éœ€è¦å°½å¿«æ›´æ–°é¡¹ç›®æ—¶é—´çº¿"}]
})
```

å¯¹è¯å†å²ä¸­çš„å·¥å…·æ¶ˆæ¯ï¼š
```
================================= Tool Message =================================
Name: MeetingAction
å¾…åŠäº‹é¡¹å·²è®°å½•åˆ°ä¼šè®®çºªè¦ï¼
```

å¦‚æœä¸è®¾ç½® `tool_message_content`ï¼Œé»˜è®¤æ˜¯ï¼š
```
================================= Tool Message =================================
Name: MeetingAction
Returning structured response: {'task': 'æ›´æ–°é¡¹ç›®æ—¶é—´çº¿', 'assignee': 'å°ç‹', 'priority': 'high'}
```


### é”™è¯¯å¤„ç†

æ¨¡å‹åœ¨ç”Ÿæˆç»“æ„åŒ–è¾“å‡ºæ—¶å¯èƒ½ä¼šå‡ºé”™ã€‚LangChain æä¾›æ™ºèƒ½é‡è¯•æœºåˆ¶è‡ªåŠ¨å¤„ç†è¿™äº›é”™è¯¯ã€‚

#### å¤šä¸ªç»“æ„åŒ–è¾“å‡ºé”™è¯¯

å½“æ¨¡å‹é”™è¯¯åœ°è°ƒç”¨å¤šä¸ªç»“æ„åŒ–è¾“å‡ºå·¥å…·æ—¶ï¼ŒAgent ä¼šæä¾›é”™è¯¯åé¦ˆå¹¶æç¤ºæ¨¡å‹é‡è¯•ï¼š

```python
from pydantic import BaseModel, Field
from typing import Union
from langchain.agents import create_agent
from langchain.agents.structured_output import ToolStrategy

class ContactInfo(BaseModel):
    name: str = Field(description="å§“å")
    email: str = Field(description="é‚®ç®±")

class EventDetails(BaseModel):
    event_name: str = Field(description="æ´»åŠ¨åç§°")
    date: str = Field(description="æ´»åŠ¨æ—¥æœŸ")

agent = create_agent(
    model="gpt-4o",
    tools=[],
    response_format=ToolStrategy(Union[ContactInfo, EventDetails])  # é»˜è®¤ handle_errors=True
)

agent.invoke({
    "messages": [{
        "role": "user", 
        "content": "æå–ä¿¡æ¯: å¼ ä¸‰ (zhangsan@email.com) æ­£åœ¨ç»„ç»‡ 3 æœˆ 15 æ—¥çš„æŠ€æœ¯å¤§ä¼š"
    }]
})
```

æ‰§è¡Œæµç¨‹ï¼š
```
================================ Human Message =================================
æå–ä¿¡æ¯: å¼ ä¸‰ (zhangsan@email.com) æ­£åœ¨ç»„ç»‡ 3 æœˆ 15 æ—¥çš„æŠ€æœ¯å¤§ä¼š

================================== Ai Message ==================================
Tool Calls:
  ContactInfo (call_1)
    Args: name: å¼ ä¸‰, email: zhangsan@email.com
  EventDetails (call_2)
    Args: event_name: æŠ€æœ¯å¤§ä¼š, date: 3æœˆ15æ—¥

================================= Tool Message =================================
Name: ContactInfo
Error: Model incorrectly returned multiple structured responses (ContactInfo, EventDetails) 
when only one is expected. Please fix your mistakes.

================================= Tool Message =================================
Name: EventDetails
Error: Model incorrectly returned multiple structured responses (ContactInfo, EventDetails) 
when only one is expected. Please fix your mistakes.

================================== Ai Message ==================================
Tool Calls:
  ContactInfo (call_3)
    Args: name: å¼ ä¸‰, email: zhangsan@email.com

================================= Tool Message =================================
Name: ContactInfo
Returning structured response: {'name': 'å¼ ä¸‰', 'email': 'zhangsan@email.com'}
```

#### Schema éªŒè¯é”™è¯¯

å½“ç»“æ„åŒ–è¾“å‡ºä¸ç¬¦åˆé¢„æœŸ schema æ—¶ï¼ŒAgent ä¼šæä¾›å…·ä½“çš„é”™è¯¯åé¦ˆï¼š

```python
from pydantic import BaseModel, Field
from langchain.agents import create_agent
from langchain.agents.structured_output import ToolStrategy

class ProductRating(BaseModel):
    rating: int | None = Field(description="è¯„åˆ† 1-5", ge=1, le=5)  # é™åˆ¶ 1-5
    comment: str = Field(description="è¯„ä»·å†…å®¹")

agent = create_agent(
    model="gpt-4o",
    tools=[],
    response_format=ToolStrategy(ProductRating),
    system_prompt="ä½ æ˜¯ä¸€ä¸ªè§£æäº§å“è¯„ä»·çš„åŠ©æ‰‹ã€‚ä¸è¦ç¼–é€ ä»»ä½•å­—æ®µæˆ–å€¼ã€‚"
)

agent.invoke({
    "messages": [{"role": "user", "content": "è§£æ: è¶…æ£’çš„äº§å“ï¼Œ10/10ï¼"}]
})
```

æ‰§è¡Œæµç¨‹ï¼š
```
================================ Human Message =================================
è§£æ: è¶…æ£’çš„äº§å“ï¼Œ10/10ï¼

================================== Ai Message ==================================
Tool Calls:
  ProductRating (call_1)
    Args: rating: 10, comment: è¶…æ£’çš„äº§å“

================================= Tool Message =================================
Name: ProductRating
Error: Failed to parse structured output for tool 'ProductRating': 
1 validation error for ProductRating.rating
Input should be less than or equal to 5 [type=less_than_equal, input_value=10, input_type=int].
Please fix your mistakes.

================================== Ai Message ==================================
Tool Calls:
  ProductRating (call_2)
    Args: rating: 5, comment: è¶…æ£’çš„äº§å“

================================= Tool Message =================================
Name: ProductRating
Returning structured response: {'rating': 5, 'comment': 'è¶…æ£’çš„äº§å“'}
```

#### é”™è¯¯å¤„ç†ç­–ç•¥

`handle_errors` å‚æ•°æ”¯æŒå¤šç§é…ç½®ï¼š

##### é»˜è®¤è¡Œä¸ºï¼ˆTrueï¼‰

```python
ToolStrategy(schema=ProductRating)  # é»˜è®¤ handle_errors=True
# æ•è·æ‰€æœ‰é”™è¯¯ï¼Œä½¿ç”¨é»˜è®¤é”™è¯¯æ¶ˆæ¯
```

##### è‡ªå®šä¹‰é”™è¯¯æ¶ˆæ¯

```python
ToolStrategy(
    schema=ProductRating,
    handle_errors="è¯·æä¾› 1-5 çš„æœ‰æ•ˆè¯„åˆ†å¹¶åŒ…å«è¯„ä»·å†…å®¹ã€‚"
)
# æ‰€æœ‰é”™è¯¯éƒ½ä½¿ç”¨è¿™ä¸ªå›ºå®šæ¶ˆæ¯
```

##### åªå¤„ç†ç‰¹å®šå¼‚å¸¸

```python
ToolStrategy(
    schema=ProductRating,
    handle_errors=ValueError  # åªé‡è¯• ValueErrorï¼Œå…¶ä»–å¼‚å¸¸ç›´æ¥æŠ›å‡º
)

ToolStrategy(
    schema=ProductRating,
    handle_errors=(ValueError, TypeError)  # åªé‡è¯•è¿™ä¸¤ç§å¼‚å¸¸
)
```

##### è‡ªå®šä¹‰é”™è¯¯å¤„ç†å‡½æ•°

```python
from langchain.agents.structured_output import (
    StructuredOutputValidationError,
    MultipleStructuredOutputsError
)

def custom_error_handler(error: Exception) -> str:
    if isinstance(error, StructuredOutputValidationError):
        return "æ ¼å¼æœ‰é—®é¢˜ï¼Œè¯·é‡è¯•ã€‚"
    elif isinstance(error, MultipleStructuredOutputsError):
        return "è¿”å›äº†å¤šä¸ªç»“æ„åŒ–è¾“å‡ºï¼Œè¯·é€‰æ‹©æœ€ç›¸å…³çš„ä¸€ä¸ªã€‚"
    else:
        return f"é”™è¯¯: {str(error)}"

agent = create_agent(
    model="gpt-4o",
    tools=[],
    response_format=ToolStrategy(
        schema=Union[ContactInfo, EventDetails],
        handle_errors=custom_error_handler
    )
)
```

##### ç¦ç”¨é”™è¯¯å¤„ç†

```python
ToolStrategy(
    schema=ProductRating,
    handle_errors=False  # æ‰€æœ‰é”™è¯¯ç›´æ¥æŠ›å‡º
)
```

### ä¸¤ç§ç­–ç•¥å¯¹æ¯”

| ç‰¹æ€§ | ProviderStrategy | ToolStrategy |
|------|------------------|--------------|
| å¯é æ€§ | é«˜ï¼ˆæä¾›å•†å¼ºåˆ¶æ‰§è¡Œ schemaï¼‰ | ä¸­ï¼ˆä¾èµ–æ¨¡å‹éµå¾ªæŒ‡ä»¤ï¼‰ |
| å…¼å®¹æ€§ | ä»…æ”¯æŒç‰¹å®šæä¾›å•† | æ‰€æœ‰æ”¯æŒå·¥å…·è°ƒç”¨çš„æ¨¡å‹ |
| é”™è¯¯å¤„ç† | æä¾›å•†å¤„ç† | å†…ç½®é‡è¯•æœºåˆ¶ |
| Union ç±»å‹ | éƒ¨åˆ†æ”¯æŒ | å®Œå…¨æ”¯æŒ |
| è‡ªå®šä¹‰æ¶ˆæ¯ | ä¸æ”¯æŒ | æ”¯æŒ |

### Schema ç±»å‹å¯¹æ¯”

| ç±»å‹ | è¿”å›å€¼ | è¿è¡Œæ—¶éªŒè¯ | é€‚ç”¨åœºæ™¯ |
|------|--------|------------|----------|
| Pydantic | å¯¹è±¡ | âœ… æœ‰ | éœ€è¦éªŒè¯ã€å¤æ‚åµŒå¥—ç»“æ„ |
| Dataclass | å­—å…¸ | âŒ æ—  | ç®€å•åœºæ™¯ |
| TypedDict | å­—å…¸ | âŒ æ—  | è½»é‡çº§ã€ç±»å‹æç¤º |
| JSON Schema | å­—å…¸ | âŒ æ—  | è·¨è¯­è¨€ã€æœ€å¤§æ§åˆ¶ |

#### æœ¬è´¨ï¼šéƒ½æ˜¯ JSON Schema

ä¸ç®¡ä½ ç”¨å“ªç§ç±»å‹å®šä¹‰ï¼ŒLangChain å†…éƒ¨éƒ½ä¼šè½¬æˆ JSON Schema å‘ç»™æ¨¡å‹ï¼š

```
ä½ å®šä¹‰çš„ç±»å‹                    å‘ç»™æ¨¡å‹çš„                æ¨¡å‹è¿”å›çš„        æœ€ç»ˆç»™ä½ çš„
     â†“                            â†“                        â†“                â†“
Pydantic/Dataclass/TypedDict â†’ JSON Schema â†’ æ¨¡å‹ç”Ÿæˆ JSON â†’ è§£æ/æ ¼å¼åŒ–
```

**å…·ä½“è¿‡ç¨‹ï¼š**

```python
# ä½ å†™çš„
class ContactInfo(BaseModel):
    name: str = Field(description="å§“å")
    email: str = Field(description="é‚®ç®±")

# LangChain å†…éƒ¨è½¬æˆ JSON Schema å‘ç»™æ¨¡å‹
{
    "type": "object",
    "properties": {
        "name": {"type": "string", "description": "å§“å"},
        "email": {"type": "string", "description": "é‚®ç®±"}
    },
    "required": ["name", "email"]
}

# æ¨¡å‹è¿”å› JSON
{"name": "å¼ ä¸‰", "email": "zhangsan@example.com"}

# LangChain æ ¼å¼åŒ–æˆä½ è¦çš„ç±»å‹
# Pydantic â†’ ContactInfo(name='å¼ ä¸‰', email='zhangsan@example.com')
# å…¶ä»–ç±»å‹ â†’ {'name': 'å¼ ä¸‰', 'email': 'zhangsan@example.com'}
```

**åŒºåˆ«åªåœ¨æœ€åä¸€æ­¥ï¼š**

| ç±»å‹ | æœ€åä¸€æ­¥åšäº†ä»€ä¹ˆ |
|------|-----------------|
| Pydantic | JSON â†’ Pydantic å¯¹è±¡ï¼ˆæœ‰éªŒè¯ï¼‰ |
| Dataclass | JSON â†’ dictï¼ˆæ— éªŒè¯ï¼‰ |
| TypedDict | JSON â†’ dictï¼ˆæ— éªŒè¯ï¼‰ |
| JSON Schema | JSON â†’ dictï¼ˆæ— éªŒè¯ï¼‰ |

Pydantic å¤šåšäº†ä¸€æ­¥éªŒè¯å’Œå¯¹è±¡è½¬æ¢ï¼Œè¿™å°±æ˜¯å®ƒ"æ›´å¼º"çš„åŸå› ã€‚

#### TypedDict vs Dataclass

åœ¨ LangChain ç»“æ„åŒ–è¾“å‡ºåœºæ™¯ä¸‹ï¼Œå®ƒä»¬æ•ˆæœä¸€æ ·ï¼ˆéƒ½è¿”å›å­—å…¸ï¼‰ã€‚ä½†åœ¨ Python æœ¬èº«æœ‰åŒºåˆ«ï¼š

| ç‰¹æ€§ | TypedDict | Dataclass |
|------|-----------|-----------|
| æœ¬è´¨ | ç±»å‹æç¤ºï¼ˆç»™å­—å…¸åŠ ç±»å‹ï¼‰ | çœŸæ­£çš„ç±» |
| è¿è¡Œæ—¶ | å°±æ˜¯æ™®é€š dict | æ˜¯ç±»çš„å®ä¾‹ |
| å®ä¾‹åŒ– | ä¸èƒ½ `TypedDict()` åˆ›å»º | å¯ä»¥ `Dataclass()` åˆ›å»º |

```python
from typing_extensions import TypedDict
from dataclasses import dataclass

# TypedDict - åªæ˜¯ç±»å‹æç¤ºï¼Œè¿è¡Œæ—¶å°±æ˜¯ dict
class PersonTD(TypedDict):
    name: str
    age: int

p1 = {"name": "å¼ ä¸‰", "age": 25}  # ç›´æ¥ç”¨å­—å…¸
# PersonTD(name="å¼ ä¸‰", age=25)  # âŒ ä¸èƒ½è¿™æ ·åˆ›å»º

# Dataclass - çœŸæ­£çš„ç±»
@dataclass
class PersonDC:
    name: str
    age: int

p2 = PersonDC(name="å¼ ä¸‰", age=25)  # âœ… å¯ä»¥å®ä¾‹åŒ–
p2.name  # å¼ ä¸‰ â† ç”¨ .å±æ€§ è®¿é—®
```

**ä¸ºä»€ä¹ˆåœ¨ LangChain é‡Œæ•ˆæœä¸€æ ·ï¼Ÿ** å› ä¸º LangChain å†…éƒ¨éƒ½æŠŠå®ƒä»¬è½¬æˆ JSON Schemaï¼Œç„¶åæŠŠæ¨¡å‹è¿”å›çš„ JSON è§£ææˆå­—å…¸è¿”å›ç»™ä½ ã€‚

#### æ€ä¹ˆé€‰ï¼Ÿ

| åœºæ™¯ | æ¨è |
|------|------|
| éœ€è¦å­—æ®µéªŒè¯ï¼ˆèŒƒå›´ã€æ ¼å¼ç­‰ï¼‰ | Pydantic |
| éœ€è¦å¯¹è±¡å¼è®¿é—® `.name` | Pydantic |
| ç®€å•åœºæ™¯ï¼Œä¸éœ€è¦éªŒè¯ | TypedDict æˆ– Dataclass |
| è·¨è¯­è¨€ã€åŠ¨æ€ç”Ÿæˆ schema | JSON Schema |

**å¤§å¤šæ•°æƒ…å†µå¯ä»¥ç”¨ Pydantic**ï¼ŒåŠŸèƒ½æœ€å…¨ï¼ŒéªŒè¯æœ€ä¸¥æ ¼ã€‚

---


## ç»„åˆä½¿ç”¨

æµå¼è¾“å‡ºå’Œç»“æ„åŒ–è¾“å‡ºå¯ä»¥ç»„åˆä½¿ç”¨ï¼Œå®ç°æ›´å¼ºå¤§çš„è¾“å‡ºæ§åˆ¶ã€‚

### æµå¼è¾“å‡ºç»“æ„åŒ–æ•°æ®

```python
from pydantic import BaseModel, Field
from langchain.agents import create_agent
from langchain.agents.structured_output import ToolStrategy

class AnalysisResult(BaseModel):
    """åˆ†æç»“æœ"""
    summary: str = Field(description="æ‘˜è¦")
    key_points: list[str] = Field(description="å…³é”®ç‚¹")
    sentiment: str = Field(description="æƒ…æ„Ÿå€¾å‘")

agent = create_agent(
    model="gpt-4o",
    tools=[],
    response_format=ToolStrategy(AnalysisResult)
)

# æµå¼è¾“å‡ºç»“æ„åŒ–æ•°æ®çš„ç”Ÿæˆè¿‡ç¨‹
for stream_mode, data in agent.stream(
    {"messages": [{"role": "user", "content": "åˆ†æè¿™æ®µæ–‡æœ¬: äº§å“å¾ˆå¥½ï¼Œä½†ä»·æ ¼åé«˜"}]},
    stream_mode=["messages", "updates"]
):
    if stream_mode == "messages":
        token, metadata = data
        if token.text:
            print(token.text, end="", flush=True)
        elif token.tool_call_chunks:
            print(f"\nå·¥å…·è°ƒç”¨ç‰‡æ®µ: {token.tool_call_chunks}")
    
    if stream_mode == "updates":
        for source, update in data.items():
            if source == "model":
                last_msg = update["messages"][-1]
                if hasattr(last_msg, 'tool_calls') and last_msg.tool_calls:
                    print(f"\nå®Œæ•´å·¥å…·è°ƒç”¨: {last_msg.tool_calls}")

# è·å–æœ€ç»ˆçš„ç»“æ„åŒ–ç»“æœ
result = agent.invoke({
    "messages": [{"role": "user", "content": "åˆ†æè¿™æ®µæ–‡æœ¬: äº§å“å¾ˆå¥½ï¼Œä½†ä»·æ ¼åé«˜"}]
})
print(f"\næœ€ç»ˆç»“æœ: {result['structured_response']}")
```

### è‡ªå®šä¹‰è¿›åº¦ + ç»“æ„åŒ–è¾“å‡º

```python
from pydantic import BaseModel, Field
from langchain.agents import create_agent
from langchain.agents.structured_output import ToolStrategy
from langchain.tools import tool, ToolRuntime
from langgraph.config import get_stream_writer

class DataAnalysis(BaseModel):
    """æ•°æ®åˆ†æç»“æœ"""
    total_records: int = Field(description="æ€»è®°å½•æ•°")
    average_value: float = Field(description="å¹³å‡å€¼")
    insights: list[str] = Field(description="æ´å¯Ÿ")

@tool
def analyze_data(dataset_name: str, runtime: ToolRuntime) -> str:
    """åˆ†ææ•°æ®é›†"""
    writer = get_stream_writer()
    
    # æµå¼è¾“å‡ºè¿›åº¦
    writer(f"æ­£åœ¨åŠ è½½æ•°æ®é›†: {dataset_name}")
    writer(f"æ•°æ®é›†åŠ è½½å®Œæˆï¼Œå…± 1000 æ¡è®°å½•")
    writer(f"æ­£åœ¨è®¡ç®—ç»Ÿè®¡æŒ‡æ ‡...")
    writer(f"åˆ†æå®Œæˆ")
    
    return f"æ•°æ®é›† {dataset_name} åˆ†æå®Œæˆ"

agent = create_agent(
    model="gpt-4o",
    tools=[analyze_data],
    response_format=ToolStrategy(DataAnalysis)
)

# åŒæ—¶æµå¼è¾“å‡ºè‡ªå®šä¹‰è¿›åº¦å’Œç»“æ„åŒ–æ•°æ®
for stream_mode, data in agent.stream(
    {"messages": [{"role": "user", "content": "åˆ†æ sales_2024 æ•°æ®é›†"}]},
    stream_mode=["custom", "updates"]
):
    if stream_mode == "custom":
        print(f"è¿›åº¦: {data}")
    
    if stream_mode == "updates":
        for source, update in data.items():
            if source == "model":
                print(f"Agent æ›´æ–°: {update}")

# è·å–ç»“æ„åŒ–ç»“æœ
result = agent.invoke({
    "messages": [{"role": "user", "content": "åˆ†æ sales_2024 æ•°æ®é›†"}]
})
print(f"ç»“æ„åŒ–ç»“æœ: {result['structured_response']}")
```

### å®é™…åº”ç”¨åœºæ™¯

#### åœºæ™¯ 1ï¼šå®æ—¶æ•°æ®æå–

```python
from pydantic import BaseModel, Field
from typing import List
from langchain.agents import create_agent
from langchain.agents.structured_output import ToolStrategy

class ExtractedEntities(BaseModel):
    """æå–çš„å®ä½“"""
    people: List[str] = Field(description="äººååˆ—è¡¨")
    organizations: List[str] = Field(description="ç»„ç»‡åç§°åˆ—è¡¨")
    locations: List[str] = Field(description="åœ°ç‚¹åˆ—è¡¨")

agent = create_agent(
    model="gpt-4o",
    response_format=ToolStrategy(ExtractedEntities)
)

# æµå¼æ˜¾ç¤ºæå–è¿›åº¦
for stream_mode, data in agent.stream(
    {"messages": [{"role": "user", "content": "æå–å®ä½“: å¼ ä¸‰åœ¨åŒ—äº¬çš„å¾®è½¯å…¬å¸å·¥ä½œ"}]},
    stream_mode=["messages"]
):
    token, metadata = data
    if token.text:
        print(token.text, end="", flush=True)
```

#### åœºæ™¯ 2ï¼šå¤šæ­¥éª¤ä»»åŠ¡è¿›åº¦è¿½è¸ª

```python
from pydantic import BaseModel, Field
from langchain.agents import create_agent
from langchain.agents.structured_output import ToolStrategy
from langchain.tools import tool
from langgraph.config import get_stream_writer

class TaskResult(BaseModel):
    """ä»»åŠ¡ç»“æœ"""
    status: str = Field(description="ä»»åŠ¡çŠ¶æ€")
    steps_completed: int = Field(description="å®Œæˆçš„æ­¥éª¤æ•°")
    final_output: str = Field(description="æœ€ç»ˆè¾“å‡º")

@tool
def process_task(task_name: str) -> str:
    """å¤„ç†ä»»åŠ¡"""
    writer = get_stream_writer()
    
    steps = ["åˆå§‹åŒ–", "æ•°æ®åŠ è½½", "å¤„ç†", "éªŒè¯", "å®Œæˆ"]
    for i, step in enumerate(steps, 1):
        writer(f"æ­¥éª¤ {i}/{len(steps)}: {step}")
    
    return f"ä»»åŠ¡ {task_name} å·²å®Œæˆ"

agent = create_agent(
    model="gpt-4o",
    tools=[process_task],
    response_format=ToolStrategy(TaskResult)
)

# å®æ—¶æ˜¾ç¤ºè¿›åº¦å¹¶è·å–ç»“æ„åŒ–ç»“æœ
for stream_mode, data in agent.stream(
    {"messages": [{"role": "user", "content": "å¤„ç†æ•°æ®æ¸…æ´—ä»»åŠ¡"}]},
    stream_mode=["custom", "updates"]
):
    if stream_mode == "custom":
        print(f"ğŸ“Š {data}")
```

---

## æ€»ç»“

### æµå¼è¾“å‡º

| æ¦‚å¿µ | è¯´æ˜ |
|------|------|
| `stream_mode="updates"` | æµå¼è¾“å‡º Agent æ­¥éª¤è¿›åº¦ |
| `stream_mode="messages"` | æµå¼è¾“å‡º LLM token |
| `stream_mode="custom"` | æµå¼è¾“å‡ºè‡ªå®šä¹‰æ•°æ® |
| `get_stream_writer()` | åœ¨å·¥å…·ä¸­è·å– stream writer |
| `subgraphs=True` | å¯ç”¨å­å›¾æµå¼è¾“å‡º |
| `tags` | æ ‡è®°æ¨¡å‹æ¥æºï¼ŒåŒºåˆ†å¤šä¸ª LLM |
| `streaming=False` | ç¦ç”¨ç‰¹å®šæ¨¡å‹çš„æµå¼è¾“å‡º |

### ç»“æ„åŒ–è¾“å‡º

| æ¦‚å¿µ | è¯´æ˜ |
|------|------|
| `response_format` | æŒ‡å®š Agent çš„è¾“å‡ºæ ¼å¼ |
| `structured_response` | ç»“æ„åŒ–å“åº”å­˜å‚¨çš„é”® |
| `ProviderStrategy` | ä½¿ç”¨æä¾›å•†åŸç”Ÿç»“æ„åŒ–è¾“å‡º |
| `ToolStrategy` | ä½¿ç”¨å·¥å…·è°ƒç”¨å®ç°ç»“æ„åŒ–è¾“å‡º |
| `handle_errors` | é”™è¯¯å¤„ç†ç­–ç•¥ |
| `tool_message_content` | è‡ªå®šä¹‰å·¥å…·æ¶ˆæ¯å†…å®¹ |
| `Union` ç±»å‹ | æ”¯æŒå¤šç§è¾“å‡ºæ ¼å¼ï¼Œæ¨¡å‹è‡ªåŠ¨é€‰æ‹© |

### ç»„åˆä½¿ç”¨çš„ä¼˜åŠ¿

1. **å®æ—¶åé¦ˆ + ç»“æ„åŒ–æ•°æ®**ï¼šç”¨æˆ·çœ‹åˆ°è¿›åº¦ï¼Œæœ€ç»ˆè·å¾—å¯è§£æçš„ç»“æœ
2. **å¤šæ­¥éª¤ä»»åŠ¡è¿½è¸ª**ï¼šæ¯ä¸ªæ­¥éª¤æµå¼è¾“å‡ºè¿›åº¦ï¼Œæœ€ç»ˆè¿”å›ç»“æ„åŒ–æ‘˜è¦
3. **è°ƒè¯•å‹å¥½**ï¼šæµå¼è¾“å‡ºå¸®åŠ©ç†è§£ Agent å†³ç­–è¿‡ç¨‹ï¼Œç»“æ„åŒ–è¾“å‡ºä¾¿äºç¨‹åºå¤„ç†
4. **ç”¨æˆ·ä½“éªŒ**ï¼šæµå¼è¾“å‡ºæå‡å“åº”æ€§ï¼Œç»“æ„åŒ–è¾“å‡ºç¡®ä¿æ•°æ®è´¨é‡

é€‰æ‹©åˆé€‚çš„è¾“å‡ºæ§åˆ¶æ–¹å¼ï¼Œå¯ä»¥è®©ä½ çš„ Agent æ—¢æœ‰è‰¯å¥½çš„ç”¨æˆ·ä½“éªŒï¼Œåˆèƒ½æä¾›å¯é çš„æ•°æ®è¾“å‡ºã€‚
